# 기술면접 준비 - HTML,CSS,JS

## 브라우저 렌더링 원리

브라우저의 기본 구조

- 사용자 인터페이스: 주소창, 이전-다음 페이지 버튼 등등
- 브라우저 엔진
- 렌더링 엔진
- 통신
- UI백엔드
- 자바스크립트 해석기
- 자료 저장소

### 랜더링 엔진

랜더링 엔진의 역할은 사용자 인터페이스의 주소창을 통해 요청한 도메인혹은 주소를 요청하여 받은 내용을 브라우저에 그리는 일이다. 기본적으로 XML, HTML, 이미지를 표시할 수 있다.

렌더링 엔진의 종류로는 게코, 웹킷 등이 있다.

랜더링 엔진의 동작 과정은 다음과 같다.

응답 받은 html로 DOM트리 구축을 위해 HTML을 파싱한다. 여기서 파싱이란 하나의 프로그램을 런타임에 동작할 수 있는 포멧으로 분석하고 변환하는 것이다. 즉 html을 브라우저가 이해하고 사용할 수 있게 만드는 과정이고 파싱 이후 응답 받은 html문서를 가지고 의미를 가지는 최소 단위 인 토큰으로 변환한다. 이 토큰의 정의는 w3c에 의해 지정되었다. 토큰화 된 html을 가지고 해당 속성 및 규칙을 정의하는 객체로 변환한다. 마지막으로 html마크업에 정의된 태그 간의 관계(부모, 자식 등)를 가지고 트리 구조로 연결합니다. 이처럼 css또한 CSSOM을 만들어 DOM과 CSSOM을 결합하여 랜더트리를 만듭니다.

하지만 이 랜더트리를 만드는 과정이 한번에 다 되는 것은 아닙니다. script같은 문을 만나면 잠시 트리만드는 걸 멈추고 js 파일을 파싱하여 옵니다. 그러나 defer같은 속성을 이용하게 되면, 문서 파싱을 멈추지 않고 문서 파싱 이후 스크립트를 실행합니다.

결국 랜더 트리가 만들어지면, 랜더링 엔진은 레이아웃 과정에 들어갑니다. 리플로우 과정이라고도 불리는 이 과정은 랜더트리 요소들의 위치를 잡아주는 과정입니다. 위치를 다 계산한 렌더링 엔진은 이제 화면에 요소를 그리기 시작합니다. 이를 페인팅 과정이라 합니다.

## 호이스팅 이란?

호이스팅이란 코드 실행전 선언된 변수와 함수 선언문, 클래스 등 이 해당 스코프의 최 상단에서 선언된 것 처럼 보이는 현상을 말한다. var키워드의 경우 문제가 없지만, let,const,class는 이제 자바스크립트가 에러를 던지기 때문에 안그래 보이지만, 호이스팅은 일어난다.

자바스크립트가 동작할 때, 두 가지 시점이 존재합니다. 하나는 평가, 하나는 실행(런타임)입니다.

자바스크립트는 평가 단계에서 실행 컨텍스트를 생성합니다. 전역 실행 컨텍스트를 시작으로 해당 컨텍스트의 렉시컬 환경을 만들어 갑니다. 렉시컬 환경이란 식별자와 식별자에 바인딩 된 값, 그리고 그 상위 스코프에 대한 참조를 기록하는 환경으로, 선언된 변수 등이 기록됩니다. 이때 컨텍스트에 선언된 변수, 함수 선언문은 컨텍스트에 속하게 됩니다. 재밋는 점은 var키워드 선언 변수, 함수 선언문과 let,const,class등이 선언된 변수는 다른 곳에 저장되어 let,const,class를 선언 이전에 호출하면 에러를 내게합니다. 결국 호이스팅은 일어나지만 접근할 수 없는 TDZ(temperal dead zone)이 생성되게 되는 겁니다.

여튼 호이스팅은 자바스크립트가 평가와 실행 단계로 구분되어 동작하기에 생기며, 변수,함수혹은 클래스가 속한 스코프의 최 상단에 선언된 것 처럼 보이는 현상이라 할 수 있겠습니다.

## **클로저 란?**

클로저란 함수와 함수가 선언된 어휘적 환경의 조합 이라고 mdn에서 정의하고 있다. 예를 들어 함수를 정의할 때,

함수 내에 변수와 해당 변수를 반환되는 함수를 선언하여 사용하는 경우에 외부 함수를 이용하여 내부 함수를 호출하여도 외부 함수에 선언된 변수는 유지된다.

더 자세히 말하면 자바스크립트는 평가 단계와 실행 단계로 구분 할 수 있고, 평가 단계에서 실행 컨텍스트가 만들어진다. 이때 해당 컨텍스트에 선언된 변수, 함수 등을 저장하는 렉시컬 환경이 생성되고, 렉시컬 환경에서 참조되는 값 혹은 참조는 가비지 컬렉터가 수집하지 않는다.

그렇기 때문에 함수호출 이후에도 함수 내부에서 선언되는 변수가 가비지 콜렉터에게 수집되지 않고 제대로 참조되어 진다.

이를 클로저 라고 한다. 그리고 가비지 콜렉터에게 수집 되지 않기 때문에 물리적 메모리를 차지하고 있음으로 해제해주는 편이 좋다.

### 태그의 박스 모델은?

html태그에는 block, inline, inline-block등의 display타입이 있다. 그중 block타입을 예로 들면 먼저 태그의 width를 지정하면 border 내부 콘텐츠의 너비가 지정한 만큼 생기고, 그 밖으로 border가 생긴다. 예를 들어

```html
width: 400px; border: 1px solid #00
```

이런 스타일의 div태그는 내부 콘텐츠 400px에 border를 양 옆 위 아래로 가짐으로 총 너비는 402픽셀이 된다.

이제 이 border를 기준으로 border외부는 margin, border와 내부 콘텐츠 사이를 padding이라고 한다.

### this에 대해서 설명해보세용

this는 함수 호출 방식에 따라 참조하는 값이 달라진다. 전역에서 this를 사용하면 node환경에서는 global객체, 브라우저 환경에서는 window객체를 참조한다.

함수에서 사용할 때를 생각해보자.

일반적으로 함수 호출로 사용하는 함수 내부에서 사용된 this는 전역 객체를 의미한다.

그러나 클래스 등에서 메소드로 사용되는 함수의 this는 메소드를 소유한 객체를 의미한다. 이때 매소드 내부 함수의 this는 일반 호출이기 때문에 전역객체를 바라본다.

생성자 함수를 통해 new키워드로 만들어진 인스턴스에서 사용되는 메소드의 this는 인스턴스를 바라보고, call, bind,apply를 통해서 호출하는 함수는 this가 참조하는 값을 지정할 수 있다.

### 이벤트 루프

이벤트 루프는 자바스크립트가 싱글(단일) 스레드 언어임에도 한번에 여러 동작을 할 수 있게 동시성을 지원해주는 개념이다.

자바스크립트는 단일 스레드로 콜 스택이라는 것이 존재한다. 이 스택에는 함수가 실행될 때 함수들이 들어가게 된다. 이때 promise나 setTimeout같은 시간이 걸릴 수 있는 동작이 실행이 되면, 자바스크립트는 전체 코드를 멈추고 이를 해결하는게 아니라, 해당 코드를 동작시켜 놓고 다음 동작을 진행한다. 이후 콜백함수들이 실행이 되는 걸 볼 수 있다.

그러면 promise, setTimeout에 실행된 콜백 함수들은 어디갔다가 콜 스택에 들어오는 걸까

사실 이 둘은 다른 대기열에 들어간다. promise는 마이크로테스크 큐에, setTimeout은 테스크 큐에 들어간다. 이 큐에 틀어간 테스크 들은 이벤트 루프를 통해서 콜 스택에 들어가게 되는 것이다. 마이크로 테스크 큐는 콜 스택이 비거나, 테스크가 끝나면 바로 실행된다. 그러나 테스크 큐에 있는 콜백은 콜 스택이비어야 스택으로 이동되기 때문에 promise와 setTimeout이 실행 된다면, promise가 먼저 실행된는 것 처럼 보인다.
