<h1>11. 원시 값과 객체의 비교</h1>

데이터 타입은 크게 원시타입과 객체 타입으로 나뉜다고 했다. 그렇다면 그 특성을 알아보자.



1. 원시값 

   1. 변경이 불가능 한 값

      원시 타입의 값은 변경이 불가능한 값이다. 이 값은 read Only인 값이다. 정확히 말하자면 변경이 불가능 한 것은 변수가 아닌 데이터 공간 내부에 있는 값이다. 그렇기에 변경이 불가능하다는 것은 재할당이 불가능하다와 다른 말이다. 변수는 언제든 재할당이 가능하다. 이와 반대로 상수는 재할당이 불가능하다(const) 하지만 할당과 변경은 다른 의미기 때문에 변경 불가능한 값과 상수를 동일시 하는 것은 문제가 있다.

      값의 할당 과정에서 우리는 공간확보, undefined할당,변수설정, 값의 재할당 순서로 진행되는 것을 알았다. 여기서 만약 값의 변경이 가능했다면 undefined에서 값을 재할당할 때, 다른  위치에 값을 넣고 변수가 가르키는 것을 변경할 게 아니라 그냥 undefined 를 바꾸면 될 일이었다. 하지만 원시 타입의 값은 변경이 불가능하기 떄문에 다른 위치의 값을 불러 와야했다. 이건 변수를 재할당 할 때도 똑같다. 또 다른 공간의 메모리에 값을 넣고 변수가 보는 방향을 바꾸는 것이다.  그렇기에 메모리 내부에 존재하는 값은 변경되지 않고 이런 특징을 불변성이라고 한다. 

      

   2. 문자열과 불변성

      원시 타입의 값을 저장하려면 일단 공간을 확보해야하고 그 공간의 확보를 위해서는 데이터타입을 사용한다 말했었다. 하지만 숫자나 문자열은 브라우저마다 다를 수 있다. 문자열의 경우 다른 값과는 다르게 문자들의 집합을 의미한다. 그렇기 때문에 그 문자들의 수에 따라서 데이터의 크기가 달라진다. 1개의 문자당 2바이트를 사용한다. 하지만 결국은 원시타입의 데이터 이기 때문에 값의 재할당이 일어나지 변경이 일어나지는 않는다. 또 문자열의 특징으로 배열과 유사하게 접근 할 수 있다. length프로퍼티를 사용할 수 있고,for문으로 돌릴 수도 있다.

      

   3.  값의 전달

      일반적으로 두 개의 변수를 선언하고 하나를 다른 하나의 변수를 참조하는 식으로 구조를 짠 코드는 하나의 변수를 변경한다고 두 변수 모두가 변하는 것은 아니라는 건 알고 있다. 이런 방식으로 값을 가져오는 것을 값을 전달한다고 한다.



2. 객체

   ​	객체는 프로퍼티의 갯수를 예측할 수도 없고 그 값도 제약이 없기 때문에 원시타입처럼 메모리 공간을 사전에 정의할 수 없다.

   1. 변경가능한 값

      객체타입의 값은 변경 가능한 값이다. 변수에 객체를 할당하면 먼저 객체의 프로퍼티를 담고 있는 메모리를 만들고 그 메모리 주소를 다른 메모리 영역에 넣는다. 객체의 식별자는 이 두번 째 메모리영역을 참조한다. 또한 객체는 변수처럼 재할당으로 값을 변경하는 것이 아니라 직접 변경할 수 있다. 재할당 없이 동적으로 값을 추가,삭제가 가능하다. 값의 복사에 있어서 변수처럼 값을 복사하여 새로운 메모리에 저장하는 것은 깊은 복사라고 한다. 하지만 객체는 내부에 많은 데이터를 갖고 있을 수 있어서 깊은 복사는 메모리의 소비가 클수 있다. 그래서 객체의 복사는 얕은 복사로 객체의 프로퍼티를 참조하는 객체를 복사한다. 물론 깊은 복사도 가능하다.

      정리해보면 얕은 복사는 객체 데이터를 담고있는 변수의 데이터를 복사하는것, 깊은 복사는 객체 데이터 자체를 복사하는것이다.

   2. 참조에 의한 전달

      앞서 말한 얕은 복사는 여러 식별자가 하나의 객체를 공유하는 것이다. 자세히 생각해보면 객체는 메모리를 2개 쓰는데, 객체 식별자의 메모리와 객체 데이터의 메모리이다. 이 객체 식별자 메모리에는 객체 데이터의 주소가 있다. 그럼 이 식별자를 복사한다면 식별자 메모리 내부에 있는 객체 데이터 메모리의 주소를 복사한다. 이런 점은 뭐 원시데이터주소(값)를 복사하는 것과 똑같다. 이런 전달은 값에 의한 전달이라 한다.

