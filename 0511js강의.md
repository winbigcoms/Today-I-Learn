# 빌트인 객체

## 원시값과 래퍼객체

원시값에 대해서 메소드를 사용하여 값을 도출하려 할 때, 원시값은 객체가 아니기 때문에 메소드가 존재하지 않지만 자바스크립트 엔진이 해당 원시값에 맞는 래퍼 객체를 생성하고 객체로서 메소드를 실행한후 그 값을 반환한다.

래퍼객체는 잠시 사용하고 다시 기존의 원시값으로 식별자가 돌아가기 때문에 래퍼객체의 내부 슬롯에 변환 이전의 주소값을 기억하고 있다.

## 암묵적 전역

선언하지 않은변수에 값을 할당하면 전역 객체의 프로퍼티로 들어간다. 이 프로퍼티는 호이스팅이 발생하지 않으며 delete연산자로 삭제가 가능하다.



# this

## this 키워드

메소드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다. 이때 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 **자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.**

**this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다.**단, **this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.**

| 함수 호출 방식                                             | this 바인딩                                                  |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                    |
| 메소드 호출                                                | 메소드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                       |
| Function.prototype.apply/call/bind 메소드에 의한 간접 호출 | Function.prototype.apply/call/bind 메소드에 첫번째 인수로 전달한 객체 |

엄격 모드에서의 this는 undefined



중첩 함수와 매소드 내부의 콜백 함수의 this가 다른 것을 바라본다. 때문에 함수의 bind메소드를 사용해서 this바인딩을 다시 해준다.

```
const obj={
	foo(){
		setTimeOut(function(){}.bind(this), 100);
	}
}
```

콜백함수의 경우 bind를 사용하고, 중첩함수의 경우 apply나 call을 써줘야한다.

```
Function.prototype.adssd.call();
```

