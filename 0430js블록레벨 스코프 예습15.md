<h1>let const와 블록레벨 스코프</h1>

## var키워드로 선언한 변수의 문제점

es5까지 변수선언키워드는 var가 유일했다 하지만 var의 특징을 유의하지 않으면 문제가 생길 수 있다.



### 변수 중복선언 허용

var 키워드로 선언한 변수는 중복 선언이 가능하다. 그렇기 때문에 변수 선언이 중복 되면 초기화문 즉 할당문이 있는 경우 나중에 선언된 값으로 할당된다.



### 함수 레벨 스코프

var 키워드로 선언한 변수는 함수 몸체만을 스코프로 인정하기 때문에 함수 외부에서 선언한 변수는 전역변수가 되고 이 변수를 함수 안에서 재선언한다면 함수의 중복 선언이 일어난다. var키워드 변수는 for문에서 선언되어도 전역변수로 취급되기 때문에 전역변수를 과하게 사용할 가능성을 높인다.



### 변수 호이스팅

var 키워드 변수는 호이스팅이 일어나 변수 선언 이전에 참조가 가능하다. 이 경우 코드의 흐름이 꼬여서 가독성을 떨어트리고 실수할 가능성을 높인다.



## let키워드

es5에서 사용하던 var키워드의 문제점을 보완하기 위해서 es6에선 새로운 변수 선언 키워드인 let과 const를 도입했다.  먼저 let에 대해서 알아보자.



### 변수 중복 선언 금지

var 키워드를 사용하면 변수의 중복 선언이 가능했다. 그러나 변수를 중복 선언하면 값을 예측하기 힘든 부작용이 있었다. let키워드는 이런 중복 선언이 불가능한 키워드 이다.



### 블록 레벨 스코프

var 키워드 변수는 함수 레벨 스코프였기 때문에 함수 내부에서 선언된 변수만을 지역변수로 인식한다. 하지만 let키워드로 만든 변수는 모든 코드 블럭을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

### 변수 호이스팅

var 키워드로 선언한 변수와 달리 let키워드로 변수를 선언하면 변수 호이스팅이 일어나지 않는 것 처럼 보인다.  var 키워드의 변수 호이스팅은 런타임 이전에 실행컨텍스트에 옮겨진 선언문들이 먼저 실행되는 것을 말한다. 그렇기 때문에 할당문이 없는 선언문은 undefined를 할당받는다. let키워드로 선언한변수는 이 선언과 할당이 분리되어 일어난다. 그렇기 때문에 실행컨텍스트에 의해 런 타임 이전에는 선언만이 실행된다. let키워드의 할당 즉 초기화는 런 타임에 선언문에 도착하면 일어난다. 만약 초기화 전에 let키워드로 선언된 변수를 참조하면 참조 에러가 발생한다. undefined로 암묵적 초기화가 일어나지만 문법으로 막아 둔 것이다. 그렇기 때문에 실행 컨텍스트의 행동 부터 런타임에 선언문을 읽기 까지 변수를 사용할 수 없는 공백기간이 생긴다. 이를 일시적 사각지대 라고 한다.

그렇다고 변수 호이스팅이 일어나지 않는 것은 아니다.

```
let foo = 1; // 전역 변수
{
console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
let foo = 2; // 지역 변수
}
```

만약 호이스팅이 일어 나지 않으면 먼저 선언된 전역변수 foo를 반환해야한다. 하지만 선언문이 먼저 실행되는 호이스팅은 일어나기 때문에 지역변수 foo를 참조할 수 없다는 에러를 반환한다.

### 전역객체와 let

전역 객체(window, global)은 코드 실행 이전에 JS엔진이 가장 먼저 생성하는 객체로 최상위의 객체이다. var키워드로 만들어낸 전역 변수와 전역 함수는 이 전역 객체의 프로퍼티가 된다.  하지만 let키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니기 때문에 전역객체의 메소드나 키워드로 접근할 수 없다.



## const 키워드 

const 키워드는 변하지 않는 변수 즉 상수를 선언하기 위해서 사용한다. 

### 선언과 초기화

const로 선언한 변수는 반드시 선언과 초기화가 동시에 이루어져야한다. 또 const 키워드는 let키워드와 같게 블록 레벨 스코프를 가지면서 변수 호이스팅이 일어나지 않는 것 처럼 보인다.

### 재할당 금지

var 키워드나 let키워드로 만든 변수는 재할당이 자유롭다. 그러나 const로 선언한 변수는 상수임으로 그 값을 변경하는 재할당을 할 수 없다.

### 상수

const 키워드로 선언한 변수에 원시값을 할당하는 경우엔 상수로 그 변수값을 변경할 수 없다. 상수는 곧 재할당이 금지된 변수라는 의미이다. 상수의 네이밍은 보통 스네이크 케이스로 짓는다.

### const 키워드와 객체

const키워드에 원시값을 넣으면 변수값을 변경할 수 없다. 하지만 const에 객체 타입 데이터를 할당하면 그 값을 변경할 수 있다. 즉 재할당의 금지 이지 값의 불변을 의미하지 않는다.

## var 와 cosnt,let

변수 선언은 기본적으로 const를 사용하며 let은 재할당이 일어나는 변수에 한정하여 사용해야한다.

다음의 상황에서 변수 선언 키워드를 잘 사용하자

- es6를 사용하면 var를 쓰지 말자
- 재할당이 필요하면 한정적으로 let을 사용한다.
- 변경이 일어나지 않고 읽기 전용인 상수는 const키워드로 선언한다.

변수 선언 시점에는 이 변수가 재할당이 될지 않될지 예측하는 것이 쉽지않고 객체는 재할당이 드물다. 따라서 일단 const로 선언하고 나중에 let으로 고쳐서 쓰자
