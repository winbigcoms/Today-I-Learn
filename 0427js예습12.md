<h1>함수</h1>

함수란?  수학에서 말하는 input function output의 과정과 비슷하게 자바스크립트에서의 함수도 입력을 받아서 처리하여 출력해내는 것이다.

자바스크립트에서 함수는 문들로 기능을 구현하고 그 문들을 코드 블럭으로 하나의 실행단위로 정의한다. 이때 변수의 활동범위인 스코프의 영역도 정해진다. 수학의 함수에서 말하는 input은 자바스크립트에서 매개변수(파라미터)라고 불린다. 출력되는 값은 return값이라 하면서 반환값이라고 하며, 함수를 호출하여 대입하는 수를 인수라고 한다.

함수는 함수 정의를 통해서 생성된다. 

```
function add(x,y){ return x+y };
```

이렇게 정의하는 것 만으로 실행이 되지만 함수 호출을 통해서도 실행이 된다.

```
add(2,4) > //6
```



함수를 사용하는 이유는 동일한 작업의 반복이 예상될 때 같은 코드를 반복해서 코딩하지 않고, 만들어 놓은 코드를 재사용함으로 유지보수의 편의성을 높이고 휴먼에러를 줄여 코드의 신뢰성을 높이기 위함이다. 또한 함수는 객체 타입이기 떄문에 식별자를 붙일 수 있고 이 식별자는 함수의 성격, 역할을 직관성있게 파악할 수 있는 이름이어야한다. 가독성이 좋은 코드가 좋은 코드이기 때문이다.



함수 리터럴

​	자바스크립트의 함수는 객체 타입으로 다른 타입의 값처럼 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수명, 매개변수, 함수몸체를 사용해서 생성한다.

```
var add = function add(x,y){ return x + y};
```

함수 이름은 곧 식별자로 식별자 네이밍 규칙을 준수해야한다. 이 식별자는 함수 몸체 내에서만 참조할 수 있고, 또 식별자를 생략할 수 있는데 이런 함수를 익명함수 라고 한다. 매개변수는 0개 이상이며 이 매개변수에 호출할 때 사용한 인수가 순서대로 들어간다. 이 매개 변수는 함수 몸체에서 변수와 동일하게 취급되기 때문에 식별자 네이밍 규칙을 준수해야한다. 함수 몸체의 경우 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.

함수는 객체 이지만 일반적인 객체와는 다르게 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 갖는다. 함수가 객체라는 것은 다른 프로그래밍 언어와 구분되는 자바스크립트의 특징이다.



함수의 정의

​	함수를 정의하는 방법은 4가지가 있다. 

```
선언문 function add(x,y){retun x+y};
표현식 var add = function(x,y){retun x+y};
생성자 var add = new Function('x','y','return x+y');
화살표 var add = (x,y)=> x+y;
```

이 모든 함수의 정의 방식은 함수를 정의한다는 점에서 동일하지만 변수의 경우 선언과 동시에 정의되는 것임으로 미묘한 차이가 있다.



함수 선언문

​	선언문을 통해서 함수를 정의하는 방식이다.

```
function add(x,y){retun x+y};
```

함수 선언문은 함수 리터럴과 형태가 동일하지만, 리터럴은 익명함수를 생성할 수 있지만, 선언문은 불가능하다. 또한 함수 선언문은 표현식이 아닌 문이기 때문에 개발자도구에서 실행하면 undefined를 반환한다.  근데 잘 생각해보면 표현식이 아닌문은 변수에 할당될 수 없다. 하지만 함수는 변수에 할당되는 것 처럼 보인다.

이렇게 동작하는 이유는 자바스크립트 엔진이 함수 리터럴을 상황에 따라 다르게 해석하기 때문이다. 함수 리터럴과 함수 선언문의 차이는 함수 이름을 생략할 수 있다는 점인데, 그 말인 즉 함수 이름이 있는 함수 리터럴은 함수 선언문 또는 함수 표현식으로 해설 될 수 있다는 의미이다.  만약 자바스크립트 엔진이 함수 리터럴을 함수 선언식으로 해석한다면 자바스크립트 엔진은 암묵적으로 함수의 이름과 동일한 식별자를 생성한다.

자바스크립트는 함수 선언문을 해석하여 함수 객체를 생성한다. 하지만 이때의 함수의 이름은 함수 내부에서만 유요한 식별자이므로 생성된 함수객체를 가리키는 식별자가 필요하다. 식별자가 없으면 생성된 함수 객체를 참조할 수 없으므로 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수를 할당한다. 그러므로 함수는 함수 이름으로 호출하는 것이 아닌 함수 식별자를 이용해서 호출한다.



함수 표현식

​	자바스크립트 함수는 객체타입의 값이다. 때문에 함수는 변수에 할당 할 수 있고 프로퍼티의 값에 들어갈 수도 있으며 배열의 요소도 되는데, 이렇게 값의 성질을 갖는 객체를 일급 객체라고 한다. 즉 함수는 일급객체이다. 그렇기에 함수를 변수에 할당할 수 있고, 이렇게 변수에 함수를 할당하는 함수 정의 방식을 함수 표현식이라고 한다.

​	함수 리터럴은 함수 이름을 생략할 수 있으며 이를 익명함수라고 한다. 익명함수라고 하더라도 함수를 호출하는 것은 식별자이기 때문에 호출이 가능하다.



함수 생성 시점과 호이스팅

​	함수를 생성하는 방법은 여러 방법이 있지만 변수에 할당하여 생성한 함수와 선언문을 사용하여 생성한 함수는 사용할 수 있는 시기가 다르다. 우리는 이전에 변수 선언문은 실행컨텍스트에 옮겨져 러닝타임 이전에 먼저 실행된다고 배웠다. 함수도 똑같이 선언문은 먼저 실행된다. 하지만 표현식으로 생성한 함수는 변수에 할당할 때 그 식별자가 생성되는 것이라 표현식 선언 이전에 사용할 수 없다. 이렇게 함수의 선언문이 변수 선언문처럼 호이스팅이 일어나는 것을 함수 호이스팅이라고 한다.

함수 표현식 선언 이전에 함수를 참조하면 undefined를 반환한다. 선언하지 않은 변수를 참조하는 것 같은 것이다. 함수 호이스팅은 함수를 호출하기 전에 선언해야 한다는 규칙을 무시함으로 함수 표현식을 사용하는 것을 권고한다.