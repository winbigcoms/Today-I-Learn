8. 제어문

   ​	제어문이란 주어진 조건에 따라 코드 블록을 실행하거나 반복 실행할 때 사용되는 문이다.

   일반적인 코드는 위에서 아래로 흐르지만, 제어문을 이용하여 그 흐름을 변화시킬 수 있다.

   

   1. 블록문

      블록문이란 0개 이상의 문을 중괄호로 묶은 것, 코드 블록이라고 한다. 자바스크립트는 블록문을 하나의 실행단위로 취급하기에 단독으로 사용할 수 있지만, 일반적으로 제어문이나 함수를 정의할 때 사용한다. 또한 const, let이 블록레벨 스코프를 가진다 라고 할 때의 블록이 이 블록이다. 추가로 중괄호로 끝이 나는 블록문의 끝에는 세미콜론을 사용하지 않는다.

   2. 조건문 - 주어진 조건식에 따라서 true 혹은 false를 반환하여 블럭의 실행을 결정한다.

      1. if-else 문

         ```
         if(조건식){}else{} / if(조건식){}else if(조건식){} ...
         ```

         if else문은 주어진 조건식의 결과가 true일 경우 if문 다음의 코드 블럭이 실행되고 false일 경우 else다음의 코드 블럭이 실행된다. 주어진 조건식은 불리언 값으로 평가되어야 하며 불리언 값이 아닐 경우 JS엔진에 의해서 암묵적으로 형변환이 일어난다. 추가적인 조건을 넣을 때는 if - else if - else if - 이런식으로 이어 사용할 수 있다. if-else 같은 조건문은 표현식이 아니기 때문에 값처럼 사용할 수 없다. 하지만 삼항 조건 연산자로 변경하여 사용하면 값처럼 사용할 수 있다.

         ```
         var s = 조건식 ? true시 문 : false 시 문
         ```

         이렇게 조건문을 사용하면 변수에 할당할 수 있다.

      2. switch문

         ```
         switch(표현식){ case 표현식1: break; case 표현식2: break; default:}
         ```

         switch문은 주어진 표현식을 평가하여 그 값과 동일한 표현식을 갖는 case문으로 이동하여 실행한다. 표현식이 일치하는 case가 없다면 default로 이동하여 실행된다. if문과는 다르게 참 거짓이 아닌 값에 따라 실행될 코드를 정할 수 있어서 그 상황에 따라 사용되어야 한다.  switch문의 특징으로 case내부에 break가 걸려 있지 않으면, case의 실행이후 끝나는 것이 아니라 다음 case로 이동하여 다시 실행한다. 이를 fall through라고 한다.

   3. 반복문 - 반복문은 조건식의 평가가 참일 경우 코드블럭을 실행하는데, 조건식이 거짓이 될 때까지 반복하여 실행한다.

      1. for문

         ```
         for(선언or할당; 조건식 ; 증감){조건식이 참이면 실행할 코드}
         ```

         조건식이 거짓이 될 때 까지 코드를 반복실행하는 for문이다. for문에서 사용할 변수를 선언 할 때, i나 j를 사용하는 것이 일반적이다. 뭘 쓰는 상관은 없다. 예를 들어

         ```
         for(var i=0; i < 5 ; i++){console.log(i)}
         ```

         이 코드의 실행 순서는 

         ```
         1. for문이 실행되면서 변수 i 가 선언 및 값으로 0이 할당된다.
         2. 선언이 종료되면 조건식이 평가된다. 지금 i는 0 이니 식은 true
         3. 조건식이 true임으로 코드 블럭이 실행된다.
         4. 코드블럭이 종료되면 증감식이 실행된다. i에 1을 더한 값을 할당한다.
         5. 조건식이 반복될 되면서 i값이 증가하고 i가 5가 되는 순간 false로 for문은 종료된다.
         ```

      2. while문 

         while문은 주어진 조건식의 평가 결과가 참이면 코드블록을 반복해서 실행한다. 값이 거짓이면 종료하는데 식이 불리언 값이 아니라면 강제 형변환으로 불리언 값으로 변환하여 구별한다. while문은 거짓일 때 까지 도는게 for문과 비슷하지만, 증감식이 없어서 실수로 무한루프를 돌게할 수 있다. 그러면 컴퓨터가 과로로 쓰러질 수 있기 때문에 특정 조건일 때 나갈 수 있도록 break문을 사용해준다.

      3. do...while문 

         do while문은 while문과 비슷하다. while문이 조건식이 먼저 나오는 것이라면, do while문은 코드 블럭이 먼저나오는 것이다.

      4. break문

         switch문과 while문에서 보았듯이 break는 반복문을 탈출하는 기능을 한다. 그렇기에 레이블문, 반복문, 스위치문이외에서 사용되면 syntaxErr를 반환한다(문법오류)

      5. continue문

         break문이 반복문을 멈추고 빠져나가는 코드였다면, 특정 조건에서 반복문을 스킵하고 다음 반복문을 돌게 하는 문법이 바로  continue문이다. 반복문 내부에서 트리거가 되는 조건을 걸고 그 조건식의 코드 블럭을 continue를 반환하게 한다면, 그 트리거는 반복문에서 결과값을 반환하지 않고 다음 반복문으로 스킵된다.

         

9. 타입 변환과 단축 평가

   타입 변환이란 값의 데이터 타입이 변화됨을 의미한다. 자바스크립트의 값은 데이터 타입을 갖는다. 하지만 자바스크립트 엔진에 의해서 그 타입은 변할 수도 있고, 개발자의 의도대로 타입을 변화 시킬 수 있다. 이렇게 엔진에 의한 의도치 않은 형변환이 암묵적 형변환이라 하며, 개발자의 의도 대로 형변환을 시키는 것을 명시적 형변환이라고 한다.

   1.  암묵적 형변환	

      자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도는 개나주고 암묵적으로 지가 형변환을 시키기도 한다. 문자열을 숫자타입으로 변환하거나 숫자를 문자로 바꾸거나 불리언이 아닌 표현식을 불리언 값으로 변환하기도 한다. 

      1. 문자열로의 변환

         표현식의 연산자 중에서 이항연산자중 더하기(+)는 데이터 타입을 문자열로 변화하는 힘이 있다. 여러 데이터 타입들을 문자열에 더하면 그 값은 문자열로 반환된다.

         ```
         0+"" ="0" /-1 + ""="-1" /NaN + "" ="NaN" / Infinity+"" = "infinity"
         ```

         이처럼 숫자만을 문자형으로 바꾸는게 아니다.

         ```
         true +"" = "true"/ false +""="false"/ null+""="null"/ undefined+"" = "undefined"
         ```

         불린 값을 문자형으로 바꾸기도 하고

         ```
         ({a:yo})+"" = "[object object]" 객체를 문자형으로 반환하고
         []+"ㅗㅜㅑ"="ㅗㅜㅑ" 배열을 더하면 더한 문자열이 출력된다.
         function(){}+"asd"="function(){}asd"로 그 함수 뒤에 문자열이 붙어나온다.
         ```

         하지만 형변환이 일어나지 않는 타입이 있는데 바로 Symbol타입이다. Symbol타입의 타입 평가는 ECMA2016 공식레포에서 이렇게 설명된다.

         ```
         Let s be the this value.
         If Type(s) is Symbol, return s.
         If Type(s) is not Object, throw a TypeError exception.
         If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.
         Return the value of s's [[SymbolData]] internal slot.
         
         ```

         http://www.ecma-international.org/ecma-262/7.0/index.html#sec-toprimitive

         즉 symbol타입은 평가에서 symbol타입이 아니면 타입에러는 반환하게 되는것이다.

         

      2. 숫자타입의 변환

         앞서서 숫자타입이 문자타입으로 변화되는 것을 보았다. 하지만 그 반대로도 변환이 된다. 이항 연산의 산술연산자중 +를 제외한 -,*,/ 모두 두 개중 하나의 항이 숫자형이고 다른 하나가 숫자형이 아니라면 그 항을 숫자형으로 변환한다.  하지만 숫자형으로 변환할 수 없다면, NaN (not a number)를 반환한다. 예를 들어

         ```
         "1"*10 = 10 / "one"*10 = NaN 
         ```

         이라는 소리이다. 하지만 산술연산자만 이렇게 형변환을 시키는 건 아니다. 

         ```
         "1">0 // true
         ```

         비교 연산자란 양 옆의 항의 크기를 비교해야하기 때문에 그 항의 값은 숫자형이어야한다. 그렇기에 엔진은 비숫자형의 항을 숫자형으로 암묵적으로 변환한다. 하지만 변환할 수 없는 경우 그 항을 NaN으로 변환하고 NaN이 있는 비교연산은 항상 false를 반환한다.

          https://www.w3schools.com/js/js_comparisons.asp

         이항연산이 아닌 단항연산에서는 +연산자가 비숫자형을 숫자형으로 변환한다. 예를 들어

         ```
         +"4" //4    +"one" //NaN   +true //1   +false //0  +null //0
         +undefined,+[10,20],+(function(){})  // NaN
         +[] //0
         +Symbol() // typeErr
         ```

         문자열의 경우 변환할 수 있으면 변환하고 안되면 NaN을 반환한다. 특수하게 불린 값은 1/0으로 변환되며 null 또한 0 이다. undefined는 NaN이며 Symbol은 앞서 봤듯이 타입에러를 일으킨다. 객체나 함수도 NaN인데  특이한건 배열이다. 빈 배열은 0 으로 반환되고 내용이 있는 배열은 NaN을 반환한다.

         

      3. 불리언값으로 변환

         자바스크립트엔진은 필요에 따라 값을 불린 타입의 데이터로 변환하기도 한다. 바로 불린이 값으로 필요할 때 이다. 예를 들어 조건문에서의 조건은 그 값이 무조건 참 혹은 거짓이어야한다. 그렇기 때문에 if문이나 while문의 조건식과 삼항연산자의 조건식의 값을 암묵적으로 불린 타입으로 변환하기도 한다. 하지만 그 변환값이 딱 true가 되거나 false로 떨어지는 건 아니다. 이런 애매한 값을 falsy값 truthy값이라고 한다. 

         | false         | falsy | true | truthy |
         | ------------- | ----- | ---- | ------ |
         | undefined     | falsy | 1    | truthy |
         | null          | falsy | "2"  | truthy |
         | 0, -0         | falsy | {}   | truthy |
         | NaN           | falsy | []   | truthy |
         | " "(빈문자열) | falsy |      |        |

         위의 표가 fasly값과 truthy값을 정리한 것이다. 문자열의 경우 비어있으면 falsy, 내용이 있으면 truthy값을 반환한다. 하지만 배열과 객체는 내용이 차있던 비어있던 truthy한 값으로 반환이 된다.

   2. 명시적 타입변환 - 개발자의 의도에 의해서 값이 명시적으로 타입을 변경하는 것이다. 메소드, 코드를 사용하여 변화시키기 때문에 그 과정이 보인다.

      1. 문자열 타입으로 변환

         1. String(값)

         2. (값).toString()

         3. 값+"문자열"

            이 세가지 방식으로 숫자형을 문자열 타입으로 변화시킬 수 있다.

      2. 숫자 타입으로 변환

         1. Number('0');

         2. parseInt("0"), parseFloat("0")

         3. +"0", -"0"

         4. "0" * 1

            위의 방식으로 문자열을 숫자형으로 변화할 수 있다. 이때 변환 할수 없으면 NaN을 반환하며 parseInt, parseFloat은 문자열 형태의 값만 사용할 수 있다.

      3. 불린타입으로 변환

         1. Boolean("x")

         2. !!"x"

            불린 타입으로 변환을 명시적으로 하는 방법은 두 가지 뿐이다. boolean의 생성자 함수는 new없이 호출하여 그 값으로 넣는 방법이다. 이때 값이 빈 문자열 "" ,0,null,undefined, NaN 인 경우 false를 반환하며 그 외의 내용이 있는 문자열, 숫자, 배열, 객체, Infinity, 

            -Infinity 들은 다 true를 반환한다. 두 번째 방법인 부정 연산자의 2중사용은 먼저 !!앞의 표현식이나 값을 불린 형으로 변환한 후 그 형태를 두번 변화시키니 본인의 true혹은 false의 값이 나온다.

   3. 단축평가

      ​	단축평가는 논리합이나 논리곱으로 평가하여 값을 내는 것이다. 논리적 연산이라 그 값이 true아니면 false라고 생각할 수 있지만 그 값은 진리값이 아닐 수 있다. 먼저 &&(논리곱연산자)는 양쪽 모두가 true여야 true를 반환한다. 그렇기때문에 첫 인자가 true라면 그 값은 두 번째 인자에서 결정이 되고, 첫 인자가 false라면 거기서 값이 결정된다. 그래서 &&연산은 첫 인자가 true면 두번 째 인자의 값이 결과로 나오고 첫 인자가 false면 false를 반환한다.

      ​	|| 연산자의 경우 두 개의 값중 하나만 true면 true를 반환한다. 그렇기 때문에 ||연산자의 값은 첫번 째 값이 false면 두번째 인자에서 결정이 되고 첫 째 값이 true인 경우 두 번째 값을 비교해서 두 번째 인자가 true면 두 번째 인자를, false면 첫 번째인자를 값으로 갖는다.

      |                      |         |
| -------------------- | ------- |
      | falsy && true        | falsy   |
      | turthy1 && turthy2   | truthy2 |
      | turthy1 && falsy     | falsy   |
      | falsy1 && falsy2     | falsy1  |
| truthy1 \|\| truthy2 | truthy1 |
      | truthy \|\| falsy    | truthy  |
| falsy1 \|\| falsy2   | falsy2  |
      | falsy \|\| truthy    | truthy  |
      
      ​	이런 단축평가는 조건적으로 if문을  대체할 수 있다. 조건식의 결과가 참으로 평가될 때 무언가를 해야한다면 조건식을 &&연산자로 대체하여 사용할 수 있고 값이 거짓일 때 무언가를 한다면|| 연산자로 대체할 수 있다.
      
      ```
      if(a == b){asd} > asd = a && b // a==b 가 참일때 수행
if(!(a == b)){asd} > asd = a||b // !(a==b)가 거짓일 때 수행
      ```
   
      이런 식으로 조건문을 대체하는 부분은 객체를 가리키는 변수에 null인지 체크하고 값을 넣을 때 유용하다. 
      
      ```
      var elem = null;
      
      var value = elem.value; // TypeError: Cannot read property 'value' of null
      var value = elem && elem.value; // null
      ```
      
      null인지 아닌지 체크하지 않고 그 값을 함수나 다른 평가식에 사용하면 에러를 발생시키기 때문에 에러를 방지 할 수 있다.
   
   



