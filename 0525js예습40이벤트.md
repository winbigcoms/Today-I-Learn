# 이벤트

## 1. 이벤트 드리븐 프로그래밍

브라우저는 처리할 특정 이벤트가 발생하면 감지하여 발생 시킨다. 이때 발생시키면서 호출되는 함수를 이벤트 핸들러 라고 하며, 이 이벤트 핸들러를 브라우저에게 호출위임하는 것을 이벤트 핸들러 등록이라고 한다.

이처럼 이벤트와 그에 대응하는 이벤트 핸들러를 통해서 사용자와 어플의 상호작용이 가능해지고 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍 이라고 한다.

## 2. 이벤트 타입

이벤트 타입은 이벤트의 종류를 나타내는 **문자열** 이며 매우 많은 종류가 있다.

### 마우스

| 이벤트 타입 | 이벤트 발생 시점                    |
| :---------- | :---------------------------------- |
| click       | 마우스 버튼을 클릭했을 때           |
| dbclick     | 마우스 버튼을 더블 클릭했을 때      |
| mousedown   | 마우스 버튼을 눌렀을 때             |
| mouseup     | 누르고 있던 마우스 버튼을 놓았을 때 |
| mousemove   | 마우스를 움직였을 때                |
| mousenter   | 마우스를 요소 안으로 이동했을 때    |
| mouseleave  | 마우스를 요소 밖으로 이동했을 때    |

### 키보드

| 이벤트 타입 | 이벤트 발생 시점                                             |
| :---------- | :----------------------------------------------------------- |
| keydown     | 모든 키를 눌렀을 때 발생한다. * control, option, shift, tab, delete, 방향 키와 문자, 숫자, 특수 문자 키를 눌렀을 때 발생한다. 단, 문자, 숫자, 특수 문자 키를 눌렀을 때는 연속적으로 발생하지만 그 외의 키를 눌렸을 때는 한번만 발생한다. |
| keypress    | 문자 키를 눌렀을 때 연속적으로 발생한다. * control, option, shift, tab, delete, 방향 키 등을 눌렸을 때는 발생하지 않고 문자, 숫자, 특수 문자 키를 눌렸을 때만 발생한다. |
| keyup       | 누르고 있던 키를 놓았을 때 한번만 발생한다. * control, option, shift, tab, delete, 방향 키와 문자, 숫자, 특수 문자 키를 놓았을 때 발생한다. |

### 포커스

| 이벤트 타입 | 이벤트 발생 시점                              |
| :---------- | :-------------------------------------------- |
| focus       | 요소가 포커스를 받았을 때 (버블링하지 않는다) |
| blur        | 요소가 포커스를 잃었을 때 (버블링하지 않는다) |

### 폼 이벤트

| 이벤트 타입 | 이벤트 발생 시점                              |
| :---------- | :-------------------------------------------- |
| submit      | submit 버튼을 클릭했을 때                     |
| reset       | reset 버튼을 클릭했을 때 (최근에는 사용 안함) |

### 값 변경 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                             |
| :--------------- | :----------------------------------------------------------- |
| input            | input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때 |
| change           | input(text, checkbox, radio), select, textarea 요소의 값이 변경되었을 때. * change 이벤트는 input 이벤트와는 달리 요소가 포커스를 잃었을 때 사용자 입력이 종료되었다고 인식하여 발생한다. 즉, 사용자가 입력을 하고 있을 때는 input 이벤트가 발생하고 사용자 입력이 종료되어 값이 변경되면 change 이벤트가 발생한다. 또 checkBox의 경우 클릭과 동시에 change이벤트가 발생한다. |
| readystatechange | HTML 문서의 로드와 파싱 상태를 나타내는 readyState 프로퍼티 값(‘loading’, ‘interactive’, ‘complete’)이 변경될 때 |

### DOM뮤테이션 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                             |
| :--------------- | :----------------------------------------------------------- |
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료되어 DOM 및 CSSOM 생성이 완료되었을 때 |

### 뷰 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                             |
| :---------- | :----------------------------------------------------------- |
| resize      | 브라우저 윈도우(window)의 크기를 리사이즈할 때 연속적으로 발생한다. * 오직 window 객체에서만 발생한다. |
| scroll      | 웹페이지(document) 또는 요소를 스크롤할 때 연속적으로 발생한다. |

### 리소스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                             |
| :---------- | :----------------------------------------------------------- |
| load        | DOMContentLoaded 이벤트 이후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료되었을 때 (주로 window 객체에서 발생) |
| unload      | 리소스가 언로드될 때(주로 새로운 페이지를 요청한 경우)       |
| abort       | 리소스 로딩이 중단되었을 때                                  |
| error       | 리소스 로딩이 실패했을 때                                    |

## 3. 이벤트 핸들러의 등록

이벤트 핸들러는 이벤트 발생시 호출할 함수이다. 이 이벤트 핸들러와 이벤트를 연결해 주어 브라우저에게 이벤트 핸들러의 호출을 위임하는 것이 이벤트 핸들러의 등록이라고 한다.

### 이벤트 핸들러 어트리뷰트 방식

html요소의 어트리뷰트에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 존재한다. 이 어트리뷰트는 on접두사와 이벤트타입을 붙여서 쓰는 방식으로 존재한다. 이때 이벤트 핸들러 어트리뷰트의 값으로 함수의 참조가 아닌 함수의 호출문으로 구성된  문을 할당한다. 

이벤트 핸들러 어트리뷰트의 값은 곧 이벤트 핸들러 함수의 몸체를 의미한다. 

```
<li onclick= 이벤트핸들러(인수)></li> ===
function onclick(e){
	이벤트 핸들러(인수);
}
```

이런 식으로 동작하는 이유는 함수의 참조를 할당하면 이벤트 핸들러에 인수를 전달하기가 곤란하기 때문이다.

### 이벤트 핸들러 프로퍼티 방식

window,Document, HTMLElement타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다. 이벤트 핸들러 프로퍼티는 어트리뷰트와 마찬가지로 onclick과 같이 on접두사에 이벤트 타입으로 이루어져 있다.

```
요소노드.onclick = function(){};
```

이벤트 핸들러를 등록하기 위해서 이벤트를 발생시킬 객체인 이벤트 타겟, 이벤트의 종류, 이벤트 핸들러가 필요하다. 단점으로 이벤트 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 점이다.

### addEventListener 메소드 방식

EventTarget.prototype.addEventListener메소드를 사용해서 이벤트 핸들러를 등록할 수 있다.

```
이벤트타겟.addEventListener('이벤트타입',핸들러[,이벤트 단계])
```

addEventListener의 특징은 하나의 이벤트 타겟에 동일한 이벤트를 여러개 걸 수 있다는 점이다.

## 4. 이벤트 핸들러 제거

addEventListener로 등록한 이벤트 핸들러를 제거하려면 removeEventListener메소드를 사용한다. 단 addEventListener로 등록할 때 사용한 인수를 그래도 사용하는데 만약 다르게 두 인수가 일치하지 않는다면 이벤트 핸들러가 제거되지 않는다. 다시말해서 이벤트 핸들러를 참조가능해야 삭제가 가능하다는 말이므로 이벤트 핸들러를 무명의 함수로 만들면 제거가 불가능하다. 단 이벤트 핸들러 내부에서 제거하는 방법은 가능하지만 이때의 이벤트 핸들러는 단 한번만 호출된다.

```
$button.addEventListener('click', function foo() {
  console.log('button click');
  // 이벤트 핸들러가 호출되면 이벤트 핸들러를 제거한다.
  // 따라서 이벤트 핸들러는 단 한번만 호출된다.
  $button.removeEventListener('click', foo);
});
```

가명 함수로도 저장이 불가능하다면 argument.callee를 사용할 수 있다. 하지만 코드 최적화를 방해하므로 엄격모드에서 사용이 금지된다. 이벤트 핸들러 프로퍼티로 등록한 이벤트 핸들러는 제거가 불가능하다. 때문에 null을 재할당해줌으로 지울 수 있다.

## 5. 이벤트 객체

이벤트가 발생하면 이벤트에 관한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다.  생성된 이벤트 핸들러의 첫 번째 매개변수에 전달된다. 때문에 이벤트 객체를 사용하기 위해서는 매개변수를 명시적으로 선언해야한다. 

### 이벤트 객체의 상속구조

이벤트가 발생하면 발생한 이벤트의 타입에 따라 다양한 타입의 이벤트 객체가 생성된다. 이벤트 객체는 아래와 같은 상속 구조를 갖는다.

![img](https://poiemaweb.com/assets/fs-images/40-4.png)

위의 Event, UIEvent 등은 생성자 함수이기 때문에 객체를 생성할 수 있다. 그렇게 만들어진 객체가 이벤트 객체이다. 이벤트 객체 또한 객체이기 때문에 프로토타입 체인의 일원이 된다. 예를 들어 클릭 이벤트 객체는 마우스이벤트 생성자함수의 인스턴스이며 그 프로토타입의 체인에 속하게 된다.

Event 인터페이스는 DOM내에서 발생한 이벤트를 나타내는데 이 인터페이스에는 공통프로퍼티가 존재하며 특수한 이벤트의 인터페이스에는 고유한 프로퍼티가 정의 되어 있다. 즉 이벤트 객체의 프로퍼티는 발생한 이벤트의 타입에 따라 달라진다.

### 이벤트 객체의 공통프로퍼티

Event인터페이스 즉 Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 UIEvent, CustomEvent, MouseEvent 등 모든 파생이벤트 객체에 상속된다. 즉 Event 인터페이스의 모든 이벤트 객체의 공통 프로퍼티를 파생 이벤트 객체에 상속한다.

| 프로퍼티         | 설명                                                         | 타입          |
| :--------------- | :----------------------------------------------------------- | :------------ |
| type             | 이벤트 타입                                                  | 문자열        |
| target           | 이벤트를 발생시킨 DOM 요소                                   | DOM 요소 노드 |
| currentTarget    | 이벤트 핸들러가 바인딩된 DOM 요소                            | DOM 요소 노드 |
| eventPhase       | 이벤트 전파 단계를 나타낸다. 0: 이벤트 없음, 1: 캡처링 단계, 2: 타깃 단계, 3: 버블링 단계 | 숫자          |
| bubbles          | 이벤트를 버블링으로 전파하는지 여부를 나타낸다. 아래 이벤트는 bubbles: false로 버블링하지 않는다.                                - 포커스 이벤트 focus/blur                        - 리소스 이벤트 load/unload/abort/error <br />- 마우스 이벤트 mouseenter/mouseleave | 불리언        |
| cancelable       | preventDefault 메소드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부를 나타낸다. 아래 이벤트는 cancelable: false로 취소할 수 없다.<br /> - 포커스 이벤트 focus/blur <br />- 리소스 이벤트 load/unload/abort/error <br />- 마우스 이벤트 dbclick/mouseenter/mouseleave | 불리언        |
| defaultPrevented | preventDefault 메소드를 호출하여 이벤트를 취소하였는지 여부를 나타낸다. | 불리언        |
| isTrusted        | 사용자의 행위에 의해 발생한 이벤트인지 여부를 나타낸다. 자바스크립트 코드를 통해 인위적으로 발생시킨 이벤트, 예를 들어 click 메소드 또는 dispatchEvent 메소드를 통해 발생시킨 이벤트인 경우, isTrusted는 false이다.(“40.11. 커스텀 이벤트” 참고) | 불리언        |
| timeStamp        | 이벤트가 발생한 시각(1970/01/01/00:00:00부터 경과한 밀리초)  | 숫자          |

### 마우스 정보 취득

click,dbclick, mouseup, mousedown, mousemove 등의 마우스 관련 이벤트가 발생하면 생성되는 MouseEvent타입의 객체는 아래와 같은 고유의 프로퍼티를 갖는다.

- 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

마우스 포인터 좌표는 MouseEvent 타입의 이벤트 객체에서 제공한다. mousedown, mouseup, mousemove 이벤트가 발생하면 생성되는 MouseEvent 타입의 이벤트 객체는 마우스 포인터의 좌표 정보를 나타내는 screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY 프로퍼티를 제공한다. 이 프로퍼티 중에서 clientX/clientY는 뷰포트(Viewport), 즉 **웹페이지의 가시 영역을 기준으로 마우스 포인터 좌표**를 나타낸다.

### 키보드 정보 취득

keydown, ketpress, keyup 이벤트가 발생하면 생성되는 이벤트 객체인 KeybrardEvent 타입의 객체는 altKey, ctrlKey, shiftKey, metaKey, key, KeyCode같은 고유한 프로퍼티를 갖는다.

## 6. 이벤트 전파

DOM트리 상에 존재하는 DOM요소 노드에서 발생한 이벤트는 DOM트리를 통해서 전파된다. 이를 이벤트 전파라고 한다. 이벤트는 window로 부터 시작해서 document를 타고 eventTarget까지 도달한다. 이 과정을 이벤트 캡쳐링이라고 하며 이벤트를 발생시킨 요소에 도달한 이벤트는 다시 window를 향해서 올라가는데 이 과정을 이벤트 버블링이라고 한다. 이벤트 핸들러는 기본적으로 이벤트 버블링 단계를 캐치한다.

이벤트 단계를 선택하기 위해서는 addEventListener를 사용해야한다. 이벤트 핸들러 프로퍼티나 이벤트 핸들러 어트리뷰트는 이벤트 단계를 잡을 수 없다. 때문에 addEventListener의 3번째 매개변수로 true를 주면 이벤트 캡쳐링의 과정을 false나 생략하면 이벤트 버블링의 과정을 선택한다.

## 7. 이벤트 위임

이벤트를 자식에게 모두 걸어주는 것은 많은 함수들을 만들어 내는 것과 같다. 때문에 이벤트 위임을 이용해서 다수의 하위 요소들에서 일어날 이벤트들을 하나의 상위 요소에 이벤트 핸들러에 등록하는 방법을 말한다. 하위 요소에서 발생한 이벤트는 버블링 단계에서 부모 요소 방향으로 전파된다. 따라서 상위 요소가 하위 요소의 이벤트를 캐치할 수 있다. 또한 자식 요소가 추가된다 한들 추가적으로 이벤트를 걸어 줄 이유가 없어진다.

이벤트 위임에서 주의할 점은 상위 요소의 이벤트 핸들러를 등록하는 것 이기 때문에 이벤트 타깃은 개발자가 기대한 요소가 아닐수도 있다. 예를들어 li에 바인딩할 이벤트 핸들러를 ul에 바인딩하면 ul에서 발생하는 이벤트도 발생한다. 때문에 개발자가 의도한대로 동작하게 하기위해서 이벤트를 발생시킨 요소가 원하는 요소가 아니라면 이벤트 핸들러를 동작하지 않게 만들어줘야한다. 

```
if( !target.matches("이벤트를 의도한 요소")) return;
matches매소드는 인수로 css선택자를 받는데 호출한 노드객체를 인수로 전달한 요소와 비교한다. 인수로 받은 선택자로 호출한 객체에 접근이 가능하면 true, 안되면 false다. 때문에 의도한 요소가 이벤트를 발생시키면 return을 스킵하고 의도한 요소가 아니면 return으로 핸들러를 종료시킨다.
```

포커스 이벤트인 focus, blur는 이벤트가 버블링 되지 않는다. 따라서 하위 요소에서 포커스 이벤트를 발생시키는 경우 이벤트 위임을 할 수 없다.

## 8. 기본 동작의 변경

### 기본 동작의 중단

DOM요소는 저마다의 기본 동작이 있다. a태그는 href의 링크로 이동함 checkBox나 radio요소는 클릭하면 체크 또는 해제된다. 이벤트 객체의 preventDefault() 메소드는 이런 기본 동작을 중단시킨다.

### 이벤트 전파 방지

이벤트 객체의 stopPropagation 메소드는 이벤트 전파를 중지시킨다. 상위 요소와 하위 요소의 이벤트를 각기 처리하기 위해서 이벤트의 전파를 중지 시킨다.

## 9. 이벤트 핸들러 내부의 this

### 이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 핸글러 내부의 this는 전역 객체 window를 가리킨다.

### 이벤트 핸들러 프로퍼티 방식, addEventListner방식

이벤트 핸들러 프로퍼티 방식과 addEventListener매소드 방식에서의 this는 이벤트를 바인딩한 DOM요소롤 가리킨다. 즉 currentTarget과 같은 요소를 바라본다.

단 클래스에서 이벤트 핸들러를 바인딩 하는 경우 this에 주의해야하는데, 클래스 내부에서 정의한 함수를 이벤트 핸들러로 this를 이용해서 바인딩하면 함수의 정의시에는 인스턴스를 생각했지만 메소드로 사용하게 되면 이벤트를 발생시킨 요소 노드를 가리키기 때문에 에러가 날 수 있다. 이를 방지 하기 위해서 이벤트 핸들러를 바인딩 할때, bind를 사용해 줌으로 메소드 내부의 this가 인스턴스를 바라보게 만들어 줘야한다.

```
   this.$button = document.querySelector('.btn');
        this.count = 0;

        // increase 메소드를 이벤트 핸들러로 등록
        // 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
        // this.$button.onclick = this.increase;
        // -> TypeError: Cannot set property 'textContent' of undefined

        // increase 메소드 내부의 this가 인스턴스를 가리키도록 한다.
        this.$button.onclick = this.increase.bind(this);
      }

      increase() {
        this.$button.textContent = ++this.count;
      }
```

매소드를 화살표 함수를 사용해서 this를 맞춰줄 수는 있지만 그때의 메소드는 인스턴스 메소드가 된다.

## 10. 이벤트 핸들러에 인수 전달하기

함수에 인수를 전달하는 시점은 함수의 호출 시점이다. 때문에 이벤트 어트리뷰트의 방식에서는 기존처럼 인수를 전달할 수 있지만, 이벤트 프로퍼티나 addEventListener를 이용할시엔 인수를 전달할 수 없다. 

때문에 외부에서 선언한 함수를 이벤트 핸들러 내부에서 호출하면서 인수를 전달해 줄 수 있다.

```
 const MIN_USER_NAME_LENGTH = 5; // 이름 최소 길이
    const $input = document.querySelector('input[type=text]');
    const $msg = document.querySelector('.message');

    const checkUserNameLength = min => {
      $msg.textContent
        = $input.value.length < min ? `이름은 ${min}자 이상 입력해 주세요` : '';
    };

    // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
    $input.onblur = () => {
      checkUserNameLength(MIN_USER_NAME_LENGTH);
    };
```

아니면 이벤트 핸들러에 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수 있다.

```
 const MIN_USER_NAME_LENGTH = 5; // 이름 최소 길이
    const $input = document.querySelector('input[type=text]');
    const $msg = document.querySelector('.message');

    // 이벤트 핸들러를 반환하는 함수
    const checkUserNameLength = min => e => {
      $msg.textContent
        = $input.value.length < min ? `이름은 ${min}자 이상 입력해 주세요` : '';
    };

    // 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달한다.
    $input.onblur = checkUserNameLength(MIN_USER_NAME_LENGTH);
```

이벤트 핸들러는 결국에 호출문 없이 함수 참조를 하는 자리이다. 그러니 return이 함수인 함수가 올 수 있다.

## 11. 커스텀 이벤트

### 커스텀 이벤트 생성

이벤트 객체는 이벤트 객체를 생성하는 생성자함수에 의해서 생성되었기 때문에 이벤트 객체를 인위적으로 만들 수 있다. 이벤트 생성자 함수 중 Event, UIEvent, MouseEvent와 같은 생성자 함수로 이벤트 객체를 생성하면 이벤트타입을 명시적으로 지정할 수 있다. 이를 커스텀 이벤트 라고 한다.

이벤트 생성자 함수의 인수는 이벤트 타입에 따른다.

```
// MouseEvent 생성자 함수로 click 이벤트 타입의 커스텀 이벤트 객체를 생성
const customEvent = new MouseEvent('click');
console.log(customEvent.type); // click
console.log(customEvent.bubbles); // false
console.log(customEvent.cancelable); // false
```

또 이벤트 타입을 임의의 문자열로 만들 수 있는데 이때는 CustomEvent라는 이벤트 생성자 함수를 사용한다.

인위적으로 만든 이벤트의 버블이나 취소프로퍼티를 true로 설정하려면 생성자 함수의 두 번째 인수로 객체를 전달해서 그 객체 프로퍼티로 전달해준다. 버블이나 취소 뿐 아니라 생성된 이벤트 타입에 맞는 프로퍼티를 추가할 수 있다. 마우스의 경우 screenX나 clientX, pageX,offsetX 버튼 정보를 나타내는 altKey, ctrlKet, shiftKey,button 등의 프로퍼티를 갖는다. 

이벤트 생성자 함수로 만들어낸 인위적인 이벤트의 isTrusted프로퍼티는 언제나 false이다.

### 커스텀 이벤트 디스패치

생성된 커스텀 이벤트는 dispatchEvent메소드로 디스패치 즉 이벤트를 발생시킬 수 있다.

커스텀 이벤트를 실행하기 위해서는 바인딩할 요소 노드에 먼저 이벤트 핸들러를 등록해 놔야한다. 그 이후에 요소 노드에 dispatchEvent매소드를 이용해서 인수로 커스텀한 이벤트를 전달한다.

이벤트를 커스텀 할때 생성자 함수에 첫 인수는 이벤트 타입이지만 두 번째 인수로는 detail이라는 프로퍼티 키에 값으로 객체를 전달하여 정보를 넣어 줄 수 있다.

addEventListener를 이요할 때 첫 인수는 이벤트 프로퍼티가 된다. 두 번째에 이벤트 핸들러가 오는데, 이벤트 프로퍼티나 이벤트 어트리뷰트로는 커스텀 이벤트를 바인딩할 수 없다. on+이벤트 타입으로 이루어진 이벤트 핸들러가 없기 때문이다.