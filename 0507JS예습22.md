# this

객체는 상태값을 나타내는 프로퍼티와 그 상태값을 조작하는 메소드로 이루어진 복합 자료 구조이다.

상태값의 동작을 나타내는 메소드는 자신이 속한 객체의 상태(프로퍼티)를 참조할 수 있어야한다. 이때 메소드가 자신의 상태값인 프로퍼티를 참조하기 위해서는 자신이 속한 객체를 참조할 수 있어야한다.

this를 자신이 속한 객체 혹은 자신이 생성할 인스턴스를 가리키는 자기 참조 변수로 사용할  수 있다. this를 통해서 자신이 속한 객체 혹은 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다.

this는 자바스크립트 엔진에 의해서 암묵적으로 생성되며 코드 어디에서든 참조할 수 있다. 함수를 호출하면 암묵적으로 arguments 객체와 this가 함수 내부에 전달된다. 그러나 this의 바인딩은 함수의 호출에 따라 동적으로 결정된다.



## this 바인딩

this가 함수 내부에서 가리키는 값은 함수의 호출에 따라 달라진다. 이 개념은 함수의 스코프를 결정하는 렉시컬 스코프와 약간 헷깔릴수 있다. 함수의 스코프는 함수의 정의시점에 결정되고 this의 바인딩될 객체는 함수의 호출에 의해 결정된다.

| 함수 호출 방법                        | this 바인딩 객체     |
| ------------------------------------- | -------------------- |
| 일반 함수 호출 ()                     | 전역객체             |
| 메소드 호출 .()                       | 메소드를 호출한 객체 |
| 생성자 함수호출 new..()               | 생성될 인스턴스객체  |
| 메소드 간접호출 Object.prototype...() | 인수                 |

기본적으로 this는 전역객체가 바인딩 된다. 때문에 일반 함수 호출로 함수를 호출하면 this는 전역객체를 바라보게 된다. 이는 매소드나 생성자함수도 마찬가지 이다. 또 매소드형식으로 호출한 함수라고 하더라도 그 내부에서 일반함수로 함수가 호출된다면 그 함수의 this는 전역객체를 바라보게 된다. 그렇기 때문에 아래와 같은 방법으로 this를 바인딩해준다.

```
const obj = {
  value: 100,
  foo() {
    // this 바인딩(obj)를 변수 that에 할당한다.
    const that = this;
    // 콜백 함수 내부에서 this 대신 that을 참조한다. 이때 this는 obj
    
    setTimeout(function () {
      console.log(that.value); // 100
    }, 100);
  }
};
```

이 외에도 명시적으로 this를 바인딩해주는 메소드들이 존재한다.

```
 Function.prototype.apply(Object,[])
 Function.prototype.call(Object,)
 Function.prototype.bind(Object)
```

위 메소드들은 함수를 호출하면서 호출한 함수의 this에 인수로 받은 객체를 바인딩해준다.

이 중 call과 apply는 인수를 전달하는 방법만 다를 뿐 this를 바인딩하는 것은 똑같다. apply의 경우 호출함 함수에 인수를 전달 할 때 배열로 묶어서 전달하고 호출한 함수를 실행한다.

```
getThisBinding.apply(thisArg, [1, 2, 3])
```

call의 경우 쉼표로 구분한 리스트 형식으로 전달한다.

```
getThisBinding.call(thisArg, 1, 2, 3)
```

이렇게 함수에 인수로 객체를 this 바인딩해주면 그 객체가 사용하지 못하는 매소드도 사용할 수 있다.

bind의 경우 call이나 apply와는 다르게 함수에 this 바인딩은해주되 호출은 하지 않는다. 즉 this바인딩 까지만 해주고 땡이라서 따로 함수호출연산자를 써줘야실행이 된다.