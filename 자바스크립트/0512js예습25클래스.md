# 클래스

자바스크립트는 프로토타입 기반 객체 지향언어이다. 하지만 다른 객체 지향 언어와는 다르게 프로토타입 기반 객체 지향 언어는 클래스가 필요없는 객체지향 프로그래밍 언어이다. 하지만 클래스 개념에  익숙한 다른 언어 개발자들을 위해서 es6에서 클래스가 새롭게 도입 되었다. 

클래스는 함수이며 기존 프로토 타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있게 해주는 것이다. 클래스를 인스턴스를 생성한다는 관점에서는 생성자 함수와 동일 하게 볼 수 있겠지만, 그 동작이 다르기 때문에 온전히 같다고 생각하면 안되겠다.

클래스와 생성자함수는 다음과 같은 차이가 있다.

1. 클래스는 new를 사용하지 않으면 에러가 난다.
2. 클래스는 상속을 지원하는 extends와 super를 지원한다.
3. 클래스는 let과 const처럼 호이스팅이 발생하지 않는 것 처럼 보인다.
4. 클래스 내 모든 코드는 암묵적으로 엄격모드가 지정되어 실행된다.
5. 클래스의 constructor, 프로토타입 매소드, 정적 메소드는 모두 프로퍼티 어트리뷰트의 나열 가능 여부인 [[Enumerable]]이 false이다.



## 클래스의 정의

클래스는 class 키워드를 사용해서 정의한다.

```
class Person{};
const Person = class {};
const Person = class Myclass{};
```

이 처럼 클래스는 다양하게 정의할 수 있고, 표현식으로도 정의할 수 있다. 표현식으로 정의할 수 있다는 것은 클래스가 일급 객체라는 것을 의미한다. 자세히 말하면 클래스는 함수이며 함수는 일급 객체이기 때문에 클래스도 일급객체가 되는 것이다.

클래스 몸체에는 프로토타입 매소드, constructor, 정적 매소드 이 세가지 메소드를 정의할 수 있다.

```
class Person{
	생성자 매소드
	constructor(name){
		인스턴스 생성 및 초기화
		this.name = name;
	}
	프로토타입 매소드
	sayHi(){
		console.log(`hi my name is ${this.name});
	}
	정적 메소드
	static sayHello(){
		console.log('hello');
	}
}
인스턴스 생성
const me = new Person('lee');
```





## 클래스 호이스팅

클래스는 정의 이전에 참조할 수 없다. const나 let처럼 에러가 난다.



## 인스턴스 생성

클래스는 함수로 평가된다. 다시말해 클래스는 생성자 함수이며 new연산자와 함께 호출되어 인스턴스를 생성한다. 하지만 생성자 함수는 일반 함수처럼 호출 할 수 있기에 new연산자를 사용하지 않아도 에러가 나지 않지만 클래스의 생성목적은 인스턴스를 만드는 것 이기 때문에 new연산자와 같이 사용하지 않으면 에러가 난다.

클래스 표현식으로 정의된 클래스의 경우, 아래 예제와 같이 클래스를 가리키는 식별자(Person)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름(MyClass)을 사용해 인스턴스를 생성하면 에러가 발생한다.

```
const Person = class MyClass{};
const me = new Person();

console.log(MyClass); //에러: 함수명처럼 클래스명은 클래스 내부에서만 사용이 가능하다.
const you = new MyClass//에러: 함수명처럼 클래스명은 클래스 내부에서만 사용이 가능하다.
```



## 메소드 

클래스 몸체에서는 0개 이상의 메소드만 선언 가능하다. 클래스의 메소드로는 constructor, 프로토타입 매소드, 정적 메소드 가 존재한다.



### constructor

constructor는 인스턴스를 생성하고 초기화를 위한 메소드이다. 그러나 클래스가 평가되어 생성한 함수 객체나 인스턴스에서는 constructor라는 메소드를 찾아 볼 수 없다. 이 constructor는 메소드가 아닌 클래스 평가로 생성된 함수 객체의 코드의 일부로 된다.

```
function Person(name){
	this.name = name
}

constructor(name){
	this.name = name
}
```

이 매소드는 다음 과 같은 특징을 갖는다.

	1. 클래스 내에서 단 하나만 존재한다. 2개 이상이면 에러가 난다.
 	2. 생략가능하다. 생략하면 암묵적으로 construtor(){}가 정의된다. 이 디폴트 constructor는 빈객체를 생성한다. 함수가 new연산자와 동시에 사용되어 호출 되면 암묵적으로 this를 빈 객체에 바인딩 하고 그 객체가 만들어질 인스턴스인 것 처럼 constructor블럭에서 인스턴스의 초기화가 일어난다.
 	3. 인스턴스 생성시 외부에서 가져올 값은 cosntructor의 매개변수로 들어온다.
 	4. 별도의 반환문을 갖고 있지 않다. this를 암묵적으로 반환한다. 명시적으로 return을 쓰면 명시한 객체가 반환된다. 단 그 값이 원시값일 경우 this를 반환한다.

### 프로토타입 매소드

생성자 함수를 사용해서 인스턴스를 만들면 프로토타입 매소드 추가를 위해 명시적으로 추가해야한다.

```
Person.prototype.sayHi = function(){ console.log(this.name)}
```

그러나 클래스의 경우 클래스 코드블럭 내에서 매소드 단축표기법식으로 정의하면 된다. 

```
class Person(){
	constructor(){}
	sayHi(){}
}
const me = new Person(){}
```

클래스로 생성한 인스턴스는 프로토타입 체인의 일원이 된다.



### 정적메소드

생성자함수의 경우 명시적으로 정적 메소드를 추가해야한다.

```
Person.hh = function(){}
```

클래스에선 메소드에 static을 붙이면 정적 매소드가 된다.

```
class Person(){
	constructor(){}
	sayHi(){}
	static hh(){}
}
```



### 클래스 매소드의 특징

1. function키워드 생략한 메소드 축약 표현
2. 콤마 불필요
3. 암묵적 엄격모드
4. 열거 불가능
5. non-constructor함수



## 인스턴스 생성과정

1. 인스턴스 생성 및 this 바인딩

   new연산자와 함께 class를 호출하면 constructor의 내부 코드가 실행되기 전에 암묵적으로 this 바인딩이 일어난다. 이 때 만들어진 빈 객체가 앞으로 생성하게 될 인스턴스가 되고, 이 인스턴스의 프로토타입으로 class의 프로토타입 프로퍼티를 가리킨다.

2. 인스턴스 초기화

   constructor 내부 코드가 실행되어 this바인딩이 된 인스턴스를 초기화한다. 다시말해 this에 바인딩 된 인스턴스 객체에 프로퍼티를 추가하고 인수를 전달한다.

3. 프로토타입, 정적 메소드 추가

   클래스 몸체에 정의한 프로토타입 메소드가 존재하면 클래스의 prototype프로터피가 가리키는 프로토타입 객체에 추가한다. 정적 메소드는 class 객체에 추가한다.

4. 인스턴스 반환

   암묵적으로 this를 반환한다.



## 프로퍼티

### 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor내부에서 정의해야 한다. constructor 내부 코드가 실행되면서 this바인딩이 암묵적으로 실행 되었기 때문에 this를 사용해서 인스턴스 프로퍼티를 추가한다. 이때 인스턴스 프로퍼티는 외부에서 접근 가능하다.



### 접근자 프로퍼티

접근자 프로퍼티는 본연의 값을 갖지 않고 다른 프로퍼티들을 이용해서 값을 낸다. 클래스에서의 접근자 프로퍼티는 생성자함수의 접근자 프로퍼티와 유사하다.



### 클래스 필드 정의 제안

인스턴스 프로퍼티를 클래스 필드에서 정의할 수 있는 제안이 올라와있다.

```
class Person {
  // 클래스 필드 정의
  name = 'Lee';
}
const me = new Person('Lee'); // Person{name:"Lee"}
```

constructor내부에서 정의하지 않음에도 인스턴스 프로퍼티를 사용가능. 이때 this를 사용하면 안된다. this는 클래스의 constructor와 매소드에서만 유효하다.



클래스 필드 정의 제안으로 인해 인스턴스 프로퍼티를 정의하는 방식은 2가지가 되었다. 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면 기존의 constructor에서 인스턴스 프로퍼티를 정의하는 방식을 사용하고, 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 없다면 기존의 constructor에서 인스턴스 프로퍼티를 정의하는 방식과 클래스 필드 정의 제안 모두 사용할 수 있다.



### private 필드 정의 제안

클래스 내부에서 사용하는 인스턴스 프로퍼티들은 기본적으로 public이다. 하지만 클래스 내부에서 #을 앞에 붙여서 변수를 선언하면 이는 private한 변수로 외부에서 접근이 불가능하다.



### static 필드 정의 제안

클래스에는 static 키워드를 사용하여 정적 메소드를 정의할 수 있다. 하지만 static 키워드를 사용하여 정적 필드를 정의할 수는 없었다. 하지만 static public 필드, static private 필드, static private 메소드를 정의할 수 있는 새로운 표준 사양인 [“Static class features”](https://github.com/tc39/proposal-static-class-features)이 2020년 3월 현재, TC39 프로세스의 stage 3(candidate)에 제안되어 있다. 



## 상속에 의한 클래스 확장

### 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 **extends 키워드**가 기본적으로 제공된다. extends 키워드를 사용한 클래스 확장은 간편하고 직관적이다. 하지만 생성자 함수는 클래와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다.



### extends 키워드

상속을 통해 클래스를 확장하려면 extends키워드를 사용하여 정의한다.

```
class Basic{}
class moew extends Basic{}
```

이때 상속받는 자식 클래스를 서브 클래스, 상속해주는 부모 클래스를 수퍼클래스 라고한다. 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐만이 아니라, 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메소드, 정적 메소드 모두 상속이 가능하다.



### 동적 상속

extends 키워드를 생성자함수를 부모로서 상속받아 클래스를 확장할 수 있지만 extends키워드로 확장되는 주체는 반드시 클래스여야한다. 자세히 말해보면 상속받는 자식은 반드시 클래스여야하지만, 상속해주는 부모는 [[construct]]내부 메소드를 갖는 함수 객체라면 가능하다. 이를 이용해서 조건에 따라 동적으로 상속받을 수 있다.

```
function Base1() {}

class Base2 {}

let condition = true;

// 조건에 따라 동적으로 상속 대상을 결정하는 서브 클래스
class Derived extends (condition ? Base1 : Base2) {}
```



### 서브 클래스의 constructor

클래스의 constructor를 생략하면  디폴트 constructor가 암묵적으로 정의된다.



### super키워드

super키워드는 함수처럼 호출할 수도 있고, this와 같이 식별자처럼 참조할 수 있는 특수한 키워드 이다. super키워드의 동작은 다음과 같다.

1. super를 호출하면 수퍼 클래스(부모 클래스의)의 consturctor를 호출한다.
2. super를 참조하면 수퍼클래스의 메소드를 호출 할 수 있다.

클래스에서 인스턴스를 만들 때 사용할 인수는 클래스인스턴스 생성할 때 인수로 주어져 클래스 언선문에서 constructor의 매개변수로 들어온다. 이때 클래스를 상속받았다면 부모 클래스의 메소드에서 사용될 값이 부모 클래스에 전달되어야한다. 그렇기 때문에 자식 클래스는 super에  constructor에서 넘어온 매개변수를 그대로 수퍼의 매개변수로 받아서 수퍼클래스로 넘길 수 있다.

super 키워드의 주의사항은 다음과 같다.

1. 서브 클래스에서 constructor를 생략하지 않는 경우 반드시 super를 호출해야한다.
2. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
3. super는 반드시 서브 클래스의 constructor에서만 호출한다. 다른 곳에서 호출하면 에러난다.



super의 참조 

1. 서브클래스의 프로토타입 메소드 내에서 super.prop은 수퍼 클래스의 프로토타입 메소드 prop을 가리킨다. 즉 서브 클래스의 super는 수퍼 클래스의 .prototype을 가리킨다.

super는 자신이 바인딩되어 있는 객체의 프로토타입을 가리킨다. 위 예제에서 Derived 클래스의 sayHi는 Derived.prototype에 바인딩되어 있고 super는 Derived.prototype의 프로토타입인 Base.prototype을 가리킨다. 따라서 super.sayHi는 Base.prototype.sayHi를 가리킨다. 단, super.sayHi, 즉 Base.prototype.sayHi를 호출할 때 call 메소드를 사용해 this를 전달하여야 한다.

call 메소드를 사용해 this를 전달하지 않고 Base.prototype.sayHi를 그대로 호출하면 Base.prototype.sayHi 메소드 내부의 this는 Base.prototype를 가리킨다. Base.prototype.sayHi 메소드는 프로토타입 메소드이기 때문에 내부의 this는 Base.prototype이 아닌 인스턴스를 가리켜야 한다. name 프로퍼티는 인스턴스에 존재하기 때문이다.

이처럼 super 참조가 동작하기 위해서는 메소드가 자신이 바인딩되어 있는 객체의 프로토타입(위 예제의 경우, Base.prototype)을 찾을 수 있어야 한다. 이를 위해 메소드는 내부 슬롯 [[HomeObject]]를 갖으며 자신이 바인딩된 객체를 가리킨다. 주의할 것은 ES6 사양에서 새롭게 정의한 메소드, 즉 ES6의 메소드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 갖는다는 것이다.

super는 서브클래스의 constructor에서만 쓰인다고 했는데 사실 아니다. 객체 릴터럴에서도 사용 가능하다. 단 메소드 축약표현으로 쓰인 코드 내부에서만 가능하다.

2. 서브클래스의 정적메소드 내에서 super.prop은 수퍼 클래스의 정적 메소드prop을 가리킨다.

```
// 수퍼 클래스
class Base {
  static sayHi() {
    return 'Hi!';
  }
}

// 서브 클래스
class Derived extends Base {
  static sayHi() {
    // super.sayHi는 수퍼 클래스의 정적 메소드를 가리킨다.
    return `${super.sayHi()} how are you doing?`;
  }
}

console.log(Derived.sayHi()); // Hi! how are you doing?
```

super를 이용해서 정적 메소드도 쓸수있다.



### 상속 클래스의 인스턴스 생성 과정

1. 서브클래스의 super호출

   자바스크립트 엔진은 클래스를 평가할 때, 수퍼 클래스와 서브 클래스를 구분하기 위해 “base” 또는 “derived”를 값으로 갖는 내부 슬롯 [[ConstructorKind]]를 갖는다. 다른 클래스를 상속받지 않는 클래스(그리고 생성자 함수)는 내부 슬롯 [[ConstructorKind]]의 값이 “base”로 설정되지만 다른 클래스를 상속받는 서브 클래스는 내부 슬롯 [[ConstructorKind]]의 값이 “derived”로 설정된다. 이를 통해 수퍼 클래스와 서브 클래스는 new 연산자와 함께 호출되었을 때의 동작이 구분된다.

    서브 클래스는 자신이 직접 인스턴스를 생성하지 않고 인스턴스 생성을 수퍼 클래스에게 위임한다. 이것이 바로 서브 클래스의 constructor에서 반드시 super를 호출해야하는 이유이다.

2. 수퍼 클래스의 인스턴스 생성과 this바인딩

   수퍼 클래스의 constructor내부의 코드가 실행 되기 이전에 this바인딩을 한다. 즉 new키워드와 함께 쓰인건 서브 클래스지만 인스턴스를 생성하는 것은 수-퍼 클래스라는 말이다. 근데 또 new와 함께 호출된 것이 서브 클래스라서 new.target은 서브 클래스를 바라본다. 

   결국 생성된 인스턴스의 프로토타입은 바로 위에 서브 클래스의 프로토타입이 존재한다.

3. 수퍼 클래스의 인스턴스 초기화

   수퍼 클래스의 cosntructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. this에 바인딩된 빈 객체에 프로퍼티를 추가하고 consturctor가 받은 인수로 초기화한다.

4. 수퍼 클래스의 프로포타입, 정적 메소드 추가

   수퍼 클래스 몸체에 프로토타입 메소드가 존재하면 수퍼클래스의 prototype프로퍼티가 가리키는 객체에 메소드로 추가된다.

5. 서브 클래스 cosntructor로 복귀, this바인딩

   super의 호출이 끝나고 컨트롤이 서브클래스의 consturctor로 복귀 한다. 이때 super의 반환값으로 나온 인스턴스가 this에 바인딩 된다. 즉 일은 수퍼클래스에서 하고 그 결과 값만 서브클래스가 this로 받는다. 즉 super가 호출되지 않으면 인스턴스가 생성되지도 this바인딩도 할수 없다.

6. 서브 클래스의 인스턴스 초기화

   this에 바인딩된 객체에 프로퍼티를 추가하고 constructor가 인수로 받은 초기값으로 인스턴스의 프로퍼티를 초기화한다.

7. 인스턴스 반환

   클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.



### 표준 빌트인 생성자 함수 확장

extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메소드를 갖는 함수 객체를 반환하는 모든 표현식을 사용할 수 있다. String, Number, Array와 같은 표준 빌트인 객체도 [[Construct]] 내부 메소드를 갖는 생성자 함수이므로 extends 키워드를 사용하여 확장할 수 있다.