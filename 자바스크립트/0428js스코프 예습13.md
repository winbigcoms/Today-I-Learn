<h1>스코프</h1>

스코프란?	

​	스코프란 변수의 활동 범위이다. 우리가 이전에 봤던 함수에서 함수명은 함수 몸체 내부에서만 유효하여 함수명의 스코프는 함수 몸체라고 했었다. 이처럼 변수는 자신이 선언된 위치에 의해서 자신이 유효한 범위(다른 코드가 변수 자신을 참조할 수 있는 범위)가 결정된다. 변수 뿐 아니라 모든 식별자는 자신의 유효범위를 자신이 선언된 위치에 의해서 결정이 되고 이 유효 범위를 스코프 라고한다.

​	스코프는 자바스크립트 엔진이 중첩된 함수에서 식별자 이름이 동일할 경우 어느 식별자를 사용할 지 검색할 때 사용하는 규칙이라고 할 수 있다. 엔진은 코드의 실행에 있어서 코드의 문맥을 고려하는데 코드의 실행위치와 주변의 코드들에 의해서 각기 다른 결과를 반환한다.

​	코드의 가장 밖에서 선언된 변수는 코드의 어디서든 참조할 수 있다. 그러나 함수 내부에서 선언된 변수는 그 코드 블럭 내부에서만 참조가 가능하다. 이 두 변수의 이름이 같아도 변수의 유효범위가 가 다른 별개의 변수이다. 만약 스코프라는 개념이 없다면 이 두 변수는 동일한 변수로 충돌을 일으키게 될 것이다.

​	그런데 식별자란 값을 식별하기 위한 이름이다. 이런 식별자가 중복이 된다면 식별함에 있어서 문제가 있을 것이 분명하다. 그렇기 때문에 식별자의 이름은 중복 될 수 없다. 다시말해 하나의 값은 단 하나의 식별자에 연결되어야 한다. 프로그래밍에서 스코프를 통해서 변수의 충돌을 방지하여 중복된 식별자를 사용할 수 있게 하는데, 이것도 같은 스코프 내에서의 중복은 허용하지 않는다.



스코프의 종류

​	스코프는 전역과 지역으로 구분된다. 전역은 변수의 선언 지점이 코드의 가장 밖인 경우 이며, 지역의 경우 함수 몸체 내부 즉 함수 내부인 경우 이다.

​	전역 변수의 경우 코드 전체를 스코프로 갖기 때문에 어디서든 참조되어 질 수 있다. 그러나 지역 변수는 자신이 선언된 지역(함수 몸체)과 그 하위 함수의 몸체에 한한 위치에서 참조되어 질 수 있다.



스코프 체인

​	함수는 전역에 걸쳐 정의 될 수 있고 함수 내부에서 다시 정의 될수도 있다. 이런 함수의 중첩이 일어난 함수에서 내부의 함수를 중첩함수, 외부의 함수를 외부함수 라고 한다. 함수가 중첩된 다는 말은 곧 함수도 중첩이 된다는 말이다. 이때 스코프는 함수의 중첩에 따라 계층적인 구조를 갖게된다. 마치 html의 구조와 비슷하다.

```
var x = 1;
function(){
	var z = 1;
	function(){
		var v = 1;
		function(){
			var b = 1;
		}
	}
}
```

​	이런 구조 라면 스코프의 넓이는 x > z > v >b 순이 될 것이다.  이런식으로 변수의 스코프가 계층적으로 연결된 것을 스코프 체인이라고 부르며 위의 예제는 x라는 전역 스코프와 나머지는 지역 스코프로 이루어 진다.

​	자바스크립트 엔진은 스코프 체인을 통해서 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 반향으로 이동하여 선언된 변수를 검색한다. 때문에 상위 스코프에서 선언된 변수도 사용이 가능한 것이다.

​	이 스코프 체인은 물리적으로 존재하는데,  엔진은 코드 실행에 앞서서 실행 컨텍스트를 실행하고 선언문을 먼저 돌린다. 또한 스코프의 계층구조를 렉시컬환경이라는 자료구조로 생성한다. 변수 선언이 실행되면 변수 식별자가 렉시컬 환경에 등록되고 변수가 할당되면 렉시켤 환경의 변수 식별자에 해당하는 값을 변경한다.

​	

​	스코프 체인에 의한 변수 검색 

​		자바스크립트 엔진은 함수에서 참조된 변수를 검색함에 있어서 참조된 지역의 스코프부터 한다. 그러고 참조된 변수와 동일한 변수가 선언되지 않았다면 그 상위 스코프로 이동하여 다시 검색한다. 이렇게 움직이는 엔진은 하위 스코프로 내려가지 않고 상위로만 움직이기에 하위 스코프에서 유요한 변수가 상위에서 유효하지 않게 된다.

​	스코프 체인에 의한 함수 검색

​		함수 또한 식별자에 해당되기 때문에 스코프를 갖는다. 

```
// 전역 함수
function foo() {
  console.log('global function foo');
}
function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }
  foo(); // ①
}
bar();
```

​		함수 선언문은 호이스팅이 실행되서 함수명과 동일한 식별자로 함수가 할당되어진다. 그 상황에서 위 예제처럼 함수가 호출되면 식별자 foo를 찾는다. 근데 함수도 변수랑 딱히 다를바 없기 때문에 현재 스코프에서 먼저 변수를 찾아 있으면 실행하는 것이다. 그렇기 때문에 스코프를 변수 검색 규칙이 아닌 식별자 검색 규칙이라고 하는 것이 적절하다.



​	함수 레벨 스코프

​		스코프에서 지역이란 함수 몸체 내부를 말하고 지역은 지역스코프를 만든다. 이는 지역 스코프가 코드 블럭이 아닌 함수에 의해서만 생성된다는 의미이다. 다른 프로그래밍 언어는 지역을 만든 기준이 모든 코드 블록인데 이런 특징을 블록 레벨 스코프라고 한다. 하지만 var키워드로 선언된 변수는 오직 함수의 몸체 즉 함수의 코드 블럭만을 지역스코프로 인정한다. 이런 특성을 함수 레벨 스코프라고 한다.

​		다시 말해서 함수가 아닌 코드 블럭에서 선언된 모든 변수는 다 전역변수 라는 의미이다. 하지만 const와 let으로 선언된 변수는 블록레벨 스코프를 지원한다.



​	렉시컬 스코프

```
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

​		위 예제의 실행 결과는 bar 함수의 상위 스코프에 따라서 결정된다. 이때 생각할 수 있는 조건은 두 가지이다. 1. 실행 시점, 2 선언시점

​	

만약 1번 방식으로 상위 스코프가 정해진다면 bar의 상위 스코프는 함수 foo와 변수 x일것이다. 2번 방식이라면 bar의 상위 스코프는 변수 x뿐일 것이다.

​	1번 방식을 동적 스코프라고 한다. 함수의 정의 시점에는 함수가 어디서 호출될지 예측할 수 없기 때문에 호출 시점에 동적으로 스코프가 결정되기 때문에 동적 스코프라고 한다.

​	2번 방식을 정적 스코프 혹은 렉시컬 스코프라고 한다. 동적 스코프처럼 상위 스코프가 변경되지 않고 고정되어 있으로 정적 스코프라고 한다. 자바스크립트는 이 정적 스코프를 따른다.

​	자바스크립트는 상위 스코프의 결정을 렉시컬 스코프로 정하기 때문에 함수를 어디서 정의했는 지에 따라서 상위 스코프를 결정한다. 그렇기 때문에 모든 함수의 정의는 함수 객체를 생성할 때 자신이 정의된 스코프를 상위 스코프로 기억하고 함수가 호출되면 사진이 기억하는 자신이 정의된 스코프를 상위 스코프로 사용한다. 그렇기 때문에 함수의 호출위치는 상위 스코프 결정에 영향을 주지 않는다.

​	위의 예제는 결국 1을 반환한다.

