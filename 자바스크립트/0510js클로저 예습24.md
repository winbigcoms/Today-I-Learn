# 클로저

클로저 in MDN : 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합

함수가 선언된 렉시컬 환경 = 함수가 선언된 스코프

자바스크립트는 렉시컬 스코프를 따르기 때문에 함수의 스코프는 함수가 정의된 시점에서 결정된다.

실행 컨텍스트의 생성에서 보았듯이 자신이 선언된 렉시컬 환경의 정보는 외부 렉시컬 환경 참조에 참조값이 연결되고 때문에 상위 레코드를 알수 있다.

다시말해서 렉시컬 환경의 외부 렉시컬 환경 참조에 저장하는 참조값 즉 함수 정의문이 평가되는 시점에 함수의 위치에 의해서 결정된다.

## 함수 객체 내부 슬롯 [[Environment]]

자바스크립트는 렉시컬 스코프를 따르기 때문에 함수가 자신이 정의된 시점의 스코프(자신의 상위 스코프)를 알아야한다. 이 정보를 담고있는 내부 슬롯이 존재하는 데 그 슬롯이 바로 [[Environment]]이다.

즉 함수 정의가 평가될 때 함수 객체가 만들어지고 자신이 정의된 위치에 따라서 상위 스코프를 알아내고 그 참조값을 [[Environment]]에 저장하는 것이다. 이때 함수 정의가 평가될 시점의 스코프 === 함수의 상위 스코프 === 코드 평가 시점에 실행중인 실행 컨텍스트의 렉시컬 환경의 참조값 이 된다.

때문에 함수는 자신의 상위 스코프를 스스로 기억하고 있고 자신이 존재하는 한 그 스코프를 기억하고 있는 것이다.

```
const x = 1;

function foo() {
  const x = 10;
  // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 기억한다.
function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

위 예제의 실행컨텍스트를 순서대로 보면

1. 코드가 로드되면서 전역 객체가 생성되고 생성이 완료 되면 전역 실행 컨텍스트가 실행 컨텍스트 스택에 올라간다.

2. 전역 실행 컨텍스트는 렉시컬 환경 하나를 만드는데, 이 렉시컬 환경은 전역실행 컨텍스트에 의해 만들어 졌으니 전역 렉시컬 환경이라 칭한다.

3. 전역 렉시컬 환경에는 '전역환경기록'(GlobalEnvironmentRecode)와 외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference)라는 두 개의 컴포넌트를 갖는다.

4. 먼저 전역 환경 기록에는 전역스코프에서 선언된 변수와 함수가 들어간다. 여기서는 변수 x와 함수 foo이다. 전역 환경 기록은 또 두 개의 컴포넌트로 나눠지는데 '객체 환경 기록'(Object environment recode)와 '선언적 환경 기록'(Declartive Environment Recode)로 나눠진다. 객체 환경기록은 함수 선언문과 var 키워드로 선언된 변수들이 들어가고 선언적 환경 기록에는 const와 let키워드로 선언된 변수나 함수가 들어간다. 이 차이는 객체 환경 기록은 내부에 BindingObject에 의해서 객체 환경 기록의 프로퍼티가 전역객체의 프로퍼티로 바인딩된다. 

   전역에서 선언된 변수나 함수가 전역객체의 프로퍼티나 메소드가 되는 이유가 이 때문이다. 여기서 foo와 x가 전역 객체인 window의 메소드와 프로퍼티가 된다. 이때 foo의 경우 함수이기 때문에 내부에 [[Enviornment]]슬롯이 존재하고 그 슬롯은 foo함수가 선언된 스코프 즉 전역 스코프의 렉시컬 환경의 참조값을 가지고 있다.

5. 외부 렉시컬 환경 참조의 경우 전역 객체의 상위 스코프가 존재하지 않으니 null이 된다.

6. 함수의 호출문에 도착하여 함수가 호출되면 함수 내부로 코드의 제어권이 이동하여 함수를 평가한다. 이때 함수 실행 컨텍스트가 생성되고 함수 코드의 평가가되고 실행되면 실행 컨텍스트 스택에 함수 실행 컨텍스트가 쌓인다 지금의 경우 foo함수 실행 컨텍스트라고 하겠다.

7. foo함수의 실행 컨텍스트도 전역 실행 컨텍스트와 비슷하게 하나의 렉시컬 환경을 만들고 환경기록(EnvironmentRecode)과 OuterLexicalEnvironmentReference 두 컴포넌트로 구성된다. 단 이때 함수 실행컨텍스트기 때문에 환경기록은 함수환경기록(Function Environment Recode)가 된다. 

8. foo 함수 내부에서 선언된 함수나 변수가 존재한다. 함수 환경 기록(Function Environment Recode)에서 이 변수를 저장한다.

9. foo함수의 외부 렉시컬 환경에 대한 참조에 대해서 보면 이 함수의 정의가 이루어진 시점의 실행 컨텍스트는 전역 실행 컨텍스트 였기 때문에 외부 렉시컬 환경에 대한 참조값은 전역 실행 컨텍스트의 렉시컬 환경을 참조한다.

10. 또 foo함수 렉시컬 환경 안의 함수 환경 레코드의 내부슬롯인 [[ThisValue]]에서 this바인딩이 이루어지는데 이건 함수 호출할 때 정해진다. 지금은 일반 함수 호출 이기에 this에 window가 바인딩 된다.

11.  그 다음 다른 함수가 호출되었기 때문에 호출과 동시에 호출된 함수의 실행 컨텍스트가 만들어지고 평가, 실행으로 실행 컨텍스트 스택에 쌓인다.

12. 지금 호출된 함수는 bar함수이다. 때문에 실행 컨텍스트 스택에 bar 함수 실행 컨텍스트가 쌓인다. foo함수와 동일하게 환경 레코드와 외부 렉시컬참조 컴포넌트를 갖는 bar 렉시컬 환경을 만든다. 이때 foo함수 내부에서 선언된 변수나 함수가 없으므로 함수환경레코드는 참조하는 것이 없고 외부 렉시컬 환경에는 전역 실행 컨텍스트의 렉시컬 환경을 참조하는 값이 있다.



## 클로저와 렉시컬 환경

클로저 : 외부 함수보다 중첩함수가 더 오래 유지되어 외부 함수 밖에서 중첩 함수를 호출해도 외부 함수의 지역 변수에 접근 할 수 있는 함수

중요 : 실행 컨텍스트 스택에서 제거 된다는 것이 렉시컬 환경의 소멸을 의미하지않음

```
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```

위 예제에서는 실행 컨텍스트 스택이  전역 > outer > 전역 > inner가 된다.

이때 inner와 전역 사이에 outer가 스택에 존재하지 않아도 inner에서 outer의 변수를 참조할 수 있다. 그 이유는 스택에서는 제외 되었지만 렉시컬 환경은 아직 유지되고 있기 때문이다. 렉시컬 환경이 소멸하지 않는 이유는 inner함수의 외부 렉시컬 환경 참조에서 outer의 렉시컬 환경을 참조하고 있기 때문이다.

