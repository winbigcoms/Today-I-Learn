# 프로프티 어트리뷰트

소스코드 로딩 과정

서버의 js 코드를 로더가 가져옴 파서가 ast구조로 변환후 인터프리터가 파싱



```
const person = {
  name: 'Lee'
};

// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
```

get 가져온다

own 상속을 제외한

PropertyDescriptor  프로퍼티 묘사



객체 리터럴로 변수에 할당하는 방법으로 객체를 만들면 ttt가 자동으로 프로퍼티 어트리뷰트에 들어간다.

데이터 프로퍼티는 키와 벨류로 구성, 접근자 프로퍼티는 get과 set으로 구성 

데이터 프로퍼티의 프로퍼티 디스크립터 객체에는 value와 writable이 존재 > 값이 존재하니 재설정의 가능여부를 설정하기 위함

get과 set은 항상 같이 만들어져야하는 것은 아니다. get 접근자 프로퍼티는 프로퍼티를 참조할 때 호출되는 함수이며 set 접근자 프로퍼티는 재선언할 때 호출되는 함수이다. 단 접근자 프로퍼티는 매소드 처럼 생겼으나 프로퍼티 임으로 실행문을 () 사용하지 않는다.



접근자프로퍼티는 스스로 값을 갖지 못한다. 때문에 다른 프로퍼티들의 값을 가지고 새로운 값을 만들어준다.

 setter의 경우 할당 받는 하나의 값을 인수로 받아야한다.

```
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
  }
  person.fullName = 'Heegun Lee';
  할당 되는 값이 name에 들어간다.
```

get은 참조용 함수기 때문에 return이 있어야하지만 set은 재할당?용 함수기 때문에 return이 있으면 안된다.



객체 프로퍼티 생성에 있어서 defineProperty메소드를 이용해 프로퍼티를 생성할 경우 인수로 프로퍼티 디스크립터와 같은 구조의 객체를 넣는데 이 객체가 프로퍼티의 프로퍼티 디스크립터가 된다. 하지만 리터럴로 선언한 것과 달리 프로퍼티 디스크립터의 값들이 false가 들어 간다.



객체가 갖는 "__proto__" 는 Object.Prototype에 존재한다.

객체의 동결 - 객체의 원시값화 단 뭐라도 바꾸고 싶으면 새로 만들어야한다.



# 생성자함수에 의한 객체 생성

리터럴로 객체를 만들 때문의 문제 : 다수의 객체를 만들때 코드량이 많아짐, 동일한 메소드에 대해서 중복해서 작업해야함



객체 생성자 함수 new Object();

함수의 인수가 없으면 빈 객체를 만듬



자바스크립트가 기본적으로 제공 - 빌트인

구조 

```
function 파스칼케이스이름 (매개변수) {
	this.프로퍼티키 = 매개변수;
	this.매소드명 = function(){};
}
```

new 연산자를 붙이면 객체를 반환, new를 안붙이면 undefined를 반환

생성자 함수의 this는 생성될 인스턴스를 가르키지만 리터럴에서의 this는 메소드를 호출한 객체를 가르킨다. 일반 함수의 this는 전역객체 window를 가르킨다.

생성자 함수의 인스턴스들은 호출 될 때 마다 매소드를 새로 만들어준다. 이를 방지하기 위해 매소드를 부모에게 할당하고 자식은 상속받아사용한다.

자바스크립트 엔진은 생성자함수에서 암묵적으로 2번 일한다. 

```
function 파스칼케이스이름 (매개변수) {
	1.
	this.프로퍼티키 = 매개변수;
	this.매소드명 = function(){};
	2.
}
```

먼저 1에서 this에 빈 객체 {} 를 묶어 준다.

2에서 return this로 현재 객체를 반환한다.



함수를 정의 함에 있어서 

함수 선언문, 함수 표현식은 생성자 함수로 호출할 수 있지만 화살표 함수는 생성자 함수로 호출할 수 없다. 또한 메소드의 경우 단축표현식으로 쓰인 메소드는 생성자함수로 사용할 수 없다.



함수는 객체지만 함수만의 특징이 있다 바로 호출이 가능하다는 점인데 호출이 가능한 이유는 함순 내부의 내부 메소드인 [[call]]가 존재하기 때문이다. 하지만 new 연산자로 생성자 함수로 호출할 수 있는 함수와 없는 함수가 존재하는 데 그 차이는 내부 메소드인 [[constructor]]가 존재하기 때문이다. 기본적으로 es6 이후 문법의 함수는 constructor가 없다.



new target > 함수 객체가 new 연산자와 같이 호출되지 않으면 undefined를 갖는다.

```
function Circle(radius) {
  // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다.
  if (!new.target) {
    // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.
    return new Circle(radius);
  }
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
```

단 new.target은 es6문법이라 구 브라우저에서는 사용 불가능이다. 구 버전에는 instanceof 연산자를 사용해서 방어코드를 만든다. instanceof 말 그대로 오른쪽의 인스턴스 인지 아닌지를 구분한다.