<h1>함수</h1>

함수란?  수학에서 말하는 input function output의 과정과 비슷하게 자바스크립트에서의 함수도 입력을 받아서 처리하여 출력해내는 것이다.

자바스크립트에서 함수는 문들로 기능을 구현하고 그 문들을 코드 블럭으로 하나의 실행단위로 정의한다. 이때 변수의 활동범위인 스코프의 영역도 정해진다. 수학의 함수에서 말하는 input은 자바스크립트에서 매개변수(파라미터)라고 불린다. 출력되는 값은 return값이라 하면서 반환값이라고 하며, 함수를 호출하여 대입하는 수를 인수라고 한다.

함수는 함수 정의를 통해서 생성된다. 

```
function add(x,y){ return x+y };
```

이렇게 정의하는 것 만으로 실행이 되지만 함수 호출을 통해서도 실행이 된다.

```
add(2,4) > //6
```



함수를 사용하는 이유는 동일한 작업의 반복이 예상될 때 같은 코드를 반복해서 코딩하지 않고, 만들어 놓은 코드를 재사용함으로 유지보수의 편의성을 높이고 휴먼에러를 줄여 코드의 신뢰성을 높이기 위함이다. 또한 함수는 객체 타입이기 떄문에 식별자를 붙일 수 있고 이 식별자는 함수의 성격, 역할을 직관성있게 파악할 수 있는 이름이어야한다. 가독성이 좋은 코드가 좋은 코드이기 때문이다.



함수 리터럴

​	자바스크립트의 함수는 객체 타입으로 다른 타입의 값처럼 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수명, 매개변수, 함수몸체를 사용해서 생성한다.

```
var add = function add(x,y){ return x + y};
```

함수 이름은 곧 식별자로 식별자 네이밍 규칙을 준수해야한다. 이 식별자는 함수 몸체 내에서만 참조할 수 있고, 또 식별자를 생략할 수 있는데 이런 함수를 익명함수 라고 한다. 매개변수는 0개 이상이며 이 매개변수에 호출할 때 사용한 인수가 순서대로 들어간다. 이 매개 변수는 함수 몸체에서 변수와 동일하게 취급되기 때문에 식별자 네이밍 규칙을 준수해야한다. 함수 몸체의 경우 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.

함수는 객체 이지만 일반적인 객체와는 다르게 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 갖는다. 함수가 객체라는 것은 다른 프로그래밍 언어와 구분되는 자바스크립트의 특징이다.



함수의 정의

​	함수를 정의하는 방법은 4가지가 있다. 

```
선언문 function add(x,y){retun x+y};
표현식 var add = function(x,y){retun x+y};
생성자 var add = new Function('x','y','return x+y');
화살표 var add = (x,y)=> x+y;
```

이 모든 함수의 정의 방식은 함수를 정의한다는 점에서 동일하지만 변수의 경우 선언과 동시에 정의되는 것임으로 미묘한 차이가 있다.



함수 선언문

​	선언문을 통해서 함수를 정의하는 방식이다.

```
function add(x,y){retun x+y};
```

함수 선언문은 함수 리터럴과 형태가 동일하지만, 리터럴은 익명함수를 생성할 수 있지만, 선언문은 불가능하다. 또한 함수 선언문은 표현식이 아닌 문이기 때문에 개발자도구에서 실행하면 undefined를 반환한다.  근데 잘 생각해보면 표현식이 아닌문은 변수에 할당될 수 없다. 하지만 함수는 변수에 할당되는 것 처럼 보인다.

이렇게 동작하는 이유는 자바스크립트 엔진이 함수 리터럴을 상황에 따라 다르게 해석하기 때문이다. 함수 리터럴과 함수 선언문의 차이는 함수 이름을 생략할 수 있다는 점인데, 그 말인 즉 함수 이름이 있는 함수 리터럴은 함수 선언문 또는 함수 표현식으로 해설 될 수 있다는 의미이다.  만약 자바스크립트 엔진이 함수 리터럴을 함수 선언식으로 해석한다면 자바스크립트 엔진은 암묵적으로 함수의 이름과 동일한 식별자를 생성한다.

자바스크립트는 함수 선언문을 해석하여 함수 객체를 생성한다. 하지만 이때의 함수의 이름은 함수 내부에서만 유요한 식별자이므로 생성된 함수객체를 가리키는 식별자가 필요하다. 식별자가 없으면 생성된 함수 객체를 참조할 수 없으므로 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수를 할당한다. 그러므로 함수는 함수 이름으로 호출하는 것이 아닌 함수 식별자를 이용해서 호출한다.



함수 표현식

​	자바스크립트 함수는 객체타입의 값이다. 때문에 함수는 변수에 할당 할 수 있고 프로퍼티의 값에 들어갈 수도 있으며 배열의 요소도 되는데, 이렇게 값의 성질을 갖는 객체를 일급 객체라고 한다. 즉 함수는 일급객체이다. 그렇기에 함수를 변수에 할당할 수 있고, 이렇게 변수에 함수를 할당하는 함수 정의 방식을 함수 표현식이라고 한다.

​	함수 리터럴은 함수 이름을 생략할 수 있으며 이를 익명함수라고 한다. 익명함수라고 하더라도 함수를 호출하는 것은 식별자이기 때문에 호출이 가능하다.



함수 생성 시점과 호이스팅

​	함수를 생성하는 방법은 여러 방법이 있지만 변수에 할당하여 생성한 함수와 선언문을 사용하여 생성한 함수는 사용할 수 있는 시기가 다르다. 우리는 이전에 변수 선언문은 실행컨텍스트에 옮겨져 러닝타임 이전에 먼저 실행된다고 배웠다. 함수도 똑같이 선언문은 먼저 실행된다. 하지만 표현식으로 생성한 함수는 변수에 할당할 때 그 식별자가 생성되는 것이라 표현식 선언 이전에 사용할 수 없다. 이렇게 함수의 선언문이 변수 선언문처럼 호이스팅이 일어나는 것을 함수 호이스팅이라고 한다.

함수 표현식 선언 이전에 함수를 참조하면 undefined를 반환한다. 선언하지 않은 변수를 참조하는 것 같은 것이다. 함수 호이스팅은 함수를 호출하기 전에 선언해야 한다는 규칙을 무시함으로 함수 표현식을 사용하는 것을 권고한다.



function 생성자 함수

​	자바스크립트의 생성자 함수로 함수를 생성할 수 있다. 

```
var add = new Function('파라미터1','파라미터2','return 기능');
console.log(add(2,3));
```

​	하지만 function생성자 함수로 생성하게 되면 클로저가 없고 또 다른 함수들과 다르게 작동하기 때문에 사용하지 말자



화살표 함수

es6에서 추가된 화살표 함수는 보다 간략하고 동작도 최소화 한 함수 이다.

```
const add = (a,b) => { a + b }
```

화살표 함수에서는 this를 사용할 수 없으며 new 를 사용해서 생성자 함수로 사용할 수 없다. 이외의 다른 차이점이 존재한다.



함수 호출

​	함수는 함수 식별자와 소괄호 안의 인수로 호출된다. add(1,2)



매개변수와 인수

​	함수 실행을 위해서 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우 매개변수를 통해서 인수를 전달한다. 인수는 값으로 평가되는 표현식이어야 한다. 인수는 함수의 호출시 소괄호 내부에서 지정되며 개수와 타입에 제한이 없다.

​	매개변수는 함수를 정의할 때 선언하며 함수 몸체에서 변수로 작용한다. 즉 함수의 호출시 함수 몸체에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 실행된다. 이는 함수의 호출시 마다 실행된다.

​	매개변수는 함수의 몸체 내부에서만 사용이 가능하다고 했다 이 말인 즉 매개변수의 스코프는 함수의 몸체가 되는 것이다.

​	함수가 호출 될때 매개변수와 인수 개수를 체크하지 않는다. 보통은 매개변수 만큼의 인수를 부여 하지만 그렇지 않아도 에러는 나지 않고, 할당되지 않은 매개변수는 undefined이다. 인수가 매개변수를 초과할 경우 이는 argument객체에 저장되지만 함수에서는 사용되지 않는다.

​	argument객체는 외부에서 넘어온 인수들이 배열의 형태로 저장된 객체이다. 여기서 배열의 형태라고 한 이유는 객체의 구조가 인덱스 번호 : 인수 이기 때문이다.



인수 확인

​	함수는 외부에서 들어오는 인수의 데이터 타입이나 그 개수를 체크하지 않는다. 그렇기 때문에 사용자가 잘못된 인수를 입력할 수도 있다. 이런 위험을 방지하기 위해서 함수 내부에서 인수가 제대로 전달된 것인지 확인할 필요가 있다.

​	또한 사용자의 실수로 인수를 받지 못했을 경우에 에러가 발생할 수 있기 때문에 매개변수에 기본값을 지정해 줄 수도 있다. es6에서 도입된 매개변수의 기본값으로 함수 선언문이나 할당문에서 매개변수에 x=0 이런 식으로 기본값을 주게 되면, 인수를 받지 못한 상황에서 이 기본값이 인수로 들어가게 된다.



매개변수의 최대 개수

​	함수의 매개변수의 갯수에는 제한이 없다. 그렇다고 무턱대고 많은 매개변수를 받게된다면 문제가 생기게 된다. 매개 변수의 경우 그 순서에 의미가 있다. 매개변수의 순서대로 인수가 들어간다. 그리고 그 매개변수 마다의 역할이 다를 수 있는데, 이런 상황에서 많은 매개변수를 받게 된다면, 그 순서때문에 문제가 생길 수 있다. 그렇기에 매개변수는 적을 수록 좋으며 3개를 넘지 않는 것을 권장한다. 또한 만약 인수로 객체를 받는 경우 그 프로퍼티 키만 정확히 지정한다면 매개변수의 순서를 신경쓰지 않아도 되고 가독성도 좋아지지만 이 경우 부수효과를 발생시킨다.



반환문

​	함수는 return 키워드를 반환값으로 이루어진 반환문을 사용하여 실행결과를 함수 외부로 반환 할 수 있다. 함수는 곧 값처럼 사용할 수 있어서 변수에 할당할 수 있다. 이때 변수에 함수 호출문으로 할당하면 그 return값이 평가 값으로 평가된다.

​	return문 이후에 문이 존재하면 그 문은 무시되고 함수를 종료되며 return 뒤에 반환될 값이 적혀있지 않는다면 그 함수는 undefined를 반환한다. 만약 return 문에서 엔터로 줄바꿈을 한다면 암묵적으로 세미콜론을 삽입해줘서 반환값이 무시되고 undefined를 반환할 수 있으니 주의한다. return문은 함수의 몸체에서만 사용이 가능하며 전역에서 반환문을 쓰면 문법에러를 반환한다.



참조에 의한 전달과 외부 상태 변경

​	함수의 데이터 타입은 객체 타입이다. 그렇기에 값을 전달 할 때 참조에 의한 전달로 전달된다. 참조에 의한 전달은 얕은 복사로 변수에 데이터가 저장된 주소를 저장하고 그 주소를 통해서 데이터에 접근하는 방식이다. 함수도 이런 식으로 작동하기 때문에 두 개 이상의 식별자가 하나의 데이터를 바라 볼 수 있다.

​	데이터를 변경할 수 있는 변수가 여러개인 경우 데이터의 상태변화를 정확히 캐치하기 어렵다. 이런 단점을 극복하기 위해서 데이터의 상태를 체크하고 있는 옵저버를 만들어서 데이터 변화를 감지하고 알려주는 용도로 사용하는 옵저버 패턴을 사용하는 등의 추가 대응이 필요하다. 다른 방법으로는 객체타입의 데이터를 원시타입처럼 사용하는 것이다. 객체를 깊은 복사를 통해서 만드는 것은 메모리를 더 많이 사용하긴 하지만 코드의 신뢰성을 높일 수 있는 방법중 하나이다.



함수의 형태들

​	즉시 실행함수

​		함수의 정의와 동시에 호출되어 실행되는 함수를 즉시 실행 함수라고한다. 이 함수는 단 한번만 실행 되며 재사용할 수 없다. 따라서 즉시 실행 함수는 익명함수로 만드는 것이 일반적이다. 함수 이름이 있는 기명 함수로 만든다 하더라도 그 함수이름은 함수 몸체 내부에서만 유효하기 때문에 함수를 다시 불러 사용할 수 없다. 

​	즉시 실행함수는 반드시 그룸 연산자() 로 묶어 주어야 하는데 그렇지 않으면 자바스크립트 엔진은 이 함수를 함수 선언문으로 인식해서 함수명이 없다는 에러를 반환한다. 이름을 주고 다시 해도 문법 에러를 반환하는데 자바스크립트 엔진의 자동 세미콜론 삽입 기능 때문에  나는 에러다.

​	즉시 실행함수를 그룹 연산자로 묶은 이유는 함수를 평가해서 함수 객체로 만들기 위함이었다. 또한 즉시 실행함수도 변수에 할당함으로 인수를 전달받을 수 있다.



​	재귀함수 

​		함수가 함수 몸체에서 자기 자신을 호출하는 함수를 재귀함수라고한다. 함수 내부에서는 함수의 식별자나 함수 이름으로 호출할 수 있다. 이 함수는 반복문을 구현하기 좋지만 무한반복을 발생시킬 문제점도 있으니 반드시 탈출조건이 필요하며 반복문보다 직관적이라고 판단될 때만 사용되어야한다.



​	중첩 함수

​		반복문처럼 함수도 중첩해서 사용할 수 있다. 외부에서 감싸고 있는 함수를 외부 함수라고하며 내부함수 혹은 중첩함수는 외부함수의 헬퍼역할을 한다.



​	콜백함수

​		어떤 일을 반복하는 함수에 있어서 작업의 내용이 조금씩만 달라져도 그 함수는 다시 작성되어야한다. 하지만 중복적으로 실행되는 기능이 존재한다면 그 기능만 먼저 정의해 두고 상황에 따라서 변해야하는 기능은 외부에서 호출해서 사용하는 것이다.

```
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);     // i를 인수로 전달하면서 f의 자리에 인수로 들어온 함수를 호출
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3
```

​	위의 예제에서는 반복문이 도는 것이 중복되는 일이었다. 하지만 값으로 반환할 값들을 상황에 따라서 변경할 수 있다. 이렇게 함수의 매개변수로 전달되는 콜백함수라고 하며 콜백함수를 매개변수로 전달받은 함수를 고차함수라고 한다.

​	고차함수는 매개변수를 통해 전달받은 콜백함수의 호출시점을 결정하여 호출한다. 그러므로 고차함수에 콜백함수를 전달할 때엔 콜백함수를 고차함수 내부에서 호출하는 것이 아니라 그 인수로 함수 자체를 전달 해야한다. 만약 콜백함수가 고차함수 내부에서만 호출되면 함수 리터럴로 정의하면서 바로 고차함수에 전달한다.

```
repeat(5, function(x){
	if (x % 2) console.log(x);
})
```

​	하지만 콜백함수여 여러곳에서 사용된다거나 콜백함수를 받는 고차함수가 자주 호출된다면 그냥 하나 선언해놓고 쓰는 편이 효율적이다.



​	순수함수와 비순수 함수

​		함수형 프로그래밍에서 외부 상태에 의존하지않고 외부 값을 변경시키지도 않는(부수효과가 없는) 함수를 순수함수라고 하며 부수효과가 있는 함수를 비순수 함수라고 한다.

​		순수함수의 특징을 생각해보면 매개변수로 받은 값만으로 계산을 하여 값을 반환하는 점이다. 즉 함수 몸체에 외부에서 선언된 변수를 사용하지않고 파라미터만 가지고 기능하는 거고 비순수함수는 외부에서 정의된 변수를 가지고 기능하는 것이라 생각할 수 있다.

 		비순수함수처럼 외부의 값을 변경시키는 일은 상태변화를 추적하는 일은 매우 힘들게 만들기 때문에 외부 상태를 변경하는 비순수 함수를 사용하는 것을 줄여야한다. 이는 다시 말해 부수효과를 최대한 줄이는 것과 같은 말이다.

​		함수형 프로그래밍은 순수함수와 보조함수의 조함으로 외부 상태를 변경하는 부수효과를 최대한 줄이고 그 상태의 불변성을 지향하는 프로그래밍 패턴이다. 로직내에 존재하는 조건문과 반복문을 제거하여 코드의 직관성을 살리고 변수 사용을 최소화, 스코프를 줄임으로 상태변경을 피하고 오류를 최소화하는 것이 함수형 프로그래밍의 목표이다.
