# 스프레드 문법

스프레드 문법을 사용할 수 있는 대상은 Array,String, Map, Set, DOM 등의 for of문으로 순회가능한 이터러블에 한정된다.

```
...[1,2,3] // 123
...'hi' // hi
... new Map([['a','1'],["b","2"]]); // ['a','1']['b','2']
...{a:1, b:2} // 타입에러 이터러블이 아닌 일반 객체는 대상이 될 수 없다.
```

스프레드 연산자는 값을 반환하는 것이 아니다. 값의 목록을 반환한다. 때문에 변수에 할 당할 수 없다. 단 함수호출문의 인수 목록, 배열 리터럴의 요소 목록, 객체 리터럴의 프로퍼티 목록 에서만 사용이 가능하다.

## 함수 호출문의 인수목록에서의 사용

배열의 요소 중 최대 값을 구함

```
const arr = [1,2,3,4];
Math.max(arr) // NaN > max의 인수는 숫자여야한다.
Math.max(...arr);
```

## 배열 리터럴 내부에서의 사용

### concat, push

배열을 이어 붙이는 경우 요소들을 이어 붙이는 것과 같은 의미이다.

```
const a = [1,2,3,4]
const b =[6,7,8,9]
const arr = a.concat(b) // 1,2,3,4,6,7,8,9
const arr = [...a,...b];
```

```
const a = [1,2,3,4]
const b =[6,7,8,9]
a.push(b) // 1,2,3,4,6,7,8,9 > push의 인수는 그대로 맨 앞의 요소가 된다. 
a[0]은 b배열이 되는 것. 때문에 배열을 풀어서 넣어줄 필요가 있다.
a.push(...b);
const arr = [...a,...b];
```

### splice

```
const a = [1,2,6,7,8];
const b = [3,4,5]
a.splice(1,0,...b) 가독성이 좋다.
```

### slice

```
const a = [1,2,3];
const b = [...a]; === const b = a.slice();
```

### 유사 배열 객체의 배열화

```
const a = {a:"1", b:"2"};
const b = [...a]
```

## 객체 리터럴 내부에서 사용하는 경우

스프레드 프로퍼티 : 일반 객체를 대상으로 사용하여 프로퍼티의 추가 변경이 가능

```
const a = {x:1,y:2};
const aCopy = {...a}; > 객체의 얕은 복사
const a = { x:1, b:2, ...{a:3,t:4}} // {x:1,b:2,a:3,t:4}객체의 병합
const aMarge = Object.assign({x:1,b:2},{a:3,t:4}); {x:1,b:2,a:3,t:4}객체의 병합
프로퍼티의 중복일 경우 뒤의 위치한 프로퍼티가 우선권(덮어 씌우기);
const Marge = { ...{x:1,b:2},...{b:3}} // x:1, b:3
```

