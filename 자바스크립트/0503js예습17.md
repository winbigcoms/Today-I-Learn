# 생성자 함수에 의한 객체 생성

객체를 만드는 방법은 여러가지이다.  그중 생성자 함수인 Object()함수를 new 연산자와 함께 호출하면 빈객체를 생성해서 반환한다. 이후 프로퍼티를 추가함으로 객체를 완성한다. 

생성자 함수란 new연산자와 함께 호출되어 객체를 만드는 함수를 말한다. 이렇게 생성자 함수를 통해서 만들어진 객체는 인스턴스라고 한다. 



## 생성자 함수

### 리터럴로 객체를 만들 때의 문제점

적은 수의 객체를 만들어 낼 때는 객체 리터럴로 객체를 생성하는 것이 더 직관성이 좋다. 하지만 같은 구성의 객체를 여러개 만들어 낼 때는 매우 비효율 적으로 여러번 같은 프로퍼티를 써야한다.



### 생성자 함수로 객체를 만들  때의 장점

생성자 함수로 객체를 만들면 동일한 구조의 객체를 찍어내듯 만들어 낼 수 있다. 이때 this를 이용해서 생성할 인스턴스를 가르킬수 있다. this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이다. 호출하는 방식에 따라서 this가 가르키는 값은 달라진다.

| 함수 호출 방식       | this가 가리키는 값                     |
| -------------------- | -------------------------------------- |
| 일반 함수로서 호출   | 전역 객체                              |
| 메소드로서 호출      | 메소드를 호출한 객체(마침표 앞의 객체) |
| 생성자 함수로서 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |

만약 new연산자 없이 생성자 함수를 호출하면 일반 함수처럼 동작한다. return이 없으니 undefined를 반환하며 그 내부의 this는 전역객체를 바라본다.



### 생성자 함수의 인스턴스 생성과정

생성자함수의 내부를 보면 명시적으로는 return문이 보이지 않는다. 자바스크립트 엔진은 암묵적으로 인스턴스를 생성하고 반환하는데 new연산자와 함께 생성자 함수를 호출하면 다음과 같은 과정을 거친다.

1. 인스턴스 생성과 this 바인딩

   암묵적으로 빈 객체를 생성한다. 이 객체가 나중에 인스턴스가 된다. 그리고 이 빈 객체를 this에 바인딩한다. 

2. 생성자 함수의 코드가 실행되며 this에 있는 인스턴스를 초기화한다. 즉 생성자 함수가 인수로 받은 초기값을 인스턴스 프로퍼티에 할당하여 이래저래 요리해서 원하는 대로 만든다.

3. 생성자 함수의 내부 코드가 끝나면 바인딩된 this가 반환된다. 그래서 return이 명시적으로 없어도 값이 나온다. 근데 만약 다른 객체를 return으로 명시적 반환을 해버리면 this가 반환되지 않고 명시한 객체를 반환한다. 단 return하는 값이 원시값이면 무시하고 this를 반환한다.

결론 : 생성자함수에서 return문은 사용하지 말자.



### 내부 메소드[[Call]] 과 [[Construct]]

함수 선언문이나 함수 표현식으로 정의한 함수는 여러 방식으로 호출할 수 있다. 함수는 객체이므로 객체가 갖고 있는 내부 슬롯과 내부 메소드를 사용할 수 있고 함수가 갖는 call이나 constructor등의 메소드를 추가적으로 가진다

함수가 일반함수로 호출되면 [[Call]]이 생성자함수로 호출되면 [[Constructor]]내부 메소드가 호출된다.

``` 
function as(){};  >> 함수 정의
as()   > 일반 함수로 호출 call 메소드 실행
new as() > 생성자 함수로 호출 consturctor 실행
```

내부 메소드 call을 갖는 함수는 callable객체로 호출할수 있다는 의미이며, constructor 메소드는 함수 객체를 의미함으로 생성자함수로 호출할 수 있는 객체를 의미한다. 그렇기 때문에 함수 객체는 constructor메소드가 있냐 없냐로 구분 할 수 있다. 있으면 constructor, 없으면 non-construtor가 된다.

### constructor와 non의 구분

자바스크립트 엔진이 함수 정의를 평가하여 함수 객체를 생성할 때, 함수 정의 방식에 따라 함수를 구분한다.

​	constructor 함수 : 함수 선언문, 함수 표현식, 클래스

​	non-constructor함수 : 메소드(es6 메소드 축약표현), 화살표함수

이때 메소드는 es6에 추가된 메소드 축약표현으로 쓰인 메소드만을 의미한다. 이처럼 함수 정의에 따라서 구분하는데 non-constructor인 함수 객체를 생성자함수로 호출하면 에러를 낸다.

```
VM590:1 Uncaught TypeError: a is not a constructor
```

단 별 생각없이 만든 함수가 생성자함수 처럼 작동할 수 있으니 조심한다.



### new 연산자

일반 함수랑 생성자 함수의 차이는 별거 없다. 그냥 new 연산자랑 같이 호출하면 생성자함수로 동작하는거다. 좀 깊게 말하면 new 연산자로 부르면 constructor 메소드가 실행되는 거고 그냥 호출하면 call 메소드가 호출되는 거다. 이렇게 차이는 new 뿐이라 생성자함수의 네이밍 컨벤션은 파스칼 케이스가 일반적이다.



### new.target

생성자 함수는 항상 new와 같이 와야하는데 사람은 실수할수 있다. 그렇기 때문에 그것에 대비하는 코드기 es6때 만들어 졌다. 바로 new.target이다. new.target은 생성자 함수가 new와 같이 호출되면 함수 자신을 가르키는데 new와 같이 호출되지 않으면 undefined를 값으로 갖는다. 이걸 이용해서 만약 함수가 new와 같이 호출되지 않아서 new.target이 undefined일 때 return값으로 new 생성자 함수를 실행해 줄 수 있다.

```
function Circle(radius) {
  // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다.
  if (!new.target) {
    // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.
    return new Circle(radius);
  }

  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
```



이렇게 실수해서 new를 빼먹었을 때 new를 붙여주는 식이다. 하지만 이 문법은 나름 최신이라 IE에서는 사용할 수 없다. 때문에 이와 같은 역할을 할수 있도록 함수를 패턴화 할 수 있다. 바로 스코프 세이프 생성자 패턴이다.

new연산자를 사용하지 않았을때와 사용했을 때 생성자함수에서 차이를 갖는 부분은 바로 this이다. this는 new와 같이 사용되지 않으면 window를 가르키고 있고 new와 같이 사용된 생성자함수에서는 함수 자신을 가르키고 있다. 이때 함수 자신을 가리키고 있다는 것은 함수에 this가 바인딩 되었다는 말이다.

바인딩이 된다면 그 바인딩 된 객체의 프로토 타입 체인에 this가 있다는 말이된다. 때문에 instanceof 연산자로 체크하면 true가 반환된다. 이 점을 이용해서 this가 생성자 함수의 프로토타입 체인이 존재하지 않을 경우 new연산자를 생성자함수에 붙여서 반환해 줄 수 있다.

```
function Circle(radius) {
  // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고
  // this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다.

  // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.
  // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.
  if (!(this instanceof Circle)) {
    // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.
    return new Circle(radius);
  }

  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}
```



대부분의 기본 생성자 함수 Object, Number, Boolean등은 new 연산자가 함께 호출 됐는지 안됐는지 확인후 적절한 값을 반환한다. 이때 function과 Object는 new연산자 없이도 new연산자를 쓴 것과 동일하게 작동하지만, String, Number, Boolean 생성자함수는 new를 쓰고 안쓰고에 차이가 있다. new연산자를 쓰면 string객체로 만들어 반환하지만 new 없이 호출하면 문자열 숫자, 불린값으로 반환한다.

