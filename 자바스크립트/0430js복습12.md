# 함수

## 함수란

사용자의 입력을 받아 결과값을 반환하는 것이다. 프로그래밍에서의 함수도 이와 같다. 그저 받은 값을 계산하는 그 과정을 문들로 구현하여 하나의 코드블럭으로 감싼 것이다.

이때 외부에서 받아올 값을 놓는 자리를 매개변수(파라미터), 기능을 구현한 코드 블럭을 함수 몸체, 그 기능의 결과로 나오는 값을 반환값이라 한다. 또 사용자가 넣어주는 입력값을 인수라고 한다.

변수는 선언을 통해서 생성하면 함수는 정의를 통해서 만들어진다. 또 변수는 참조하여 불러오지만 함수는 호출하여 불러온다. 

## 함수..그것의 사용이유

함수는 결국 기능을 만들어서 정의해놓은 것이다. 그럼 왜 이렇게 해놨을 까? 결국 쓰고 또 쓰고하려고 만든거다. 한번만 쓸꺼면 뭐 만들수도 안만들 수도 있겠지만 여러번 쓸 상황이라면 그때 마다 만들어 쓸 바엔 하나 만들어 놓고 계속 쓰려고 만든거다. 코딩에서 이렇게 쓰고 또 쓰려고 만든다 라는 것을 코드의 재사용을 위해서 만든다 라고한다.

그럼 재사용 말고도 다른 이익이 있을까? 당연히 있다. 사람은 실수의 동물인데 똑같은 기능을 여러번 만들 때 실수를 하지 않을까? 100%라는 건 없지만 가능성이 높다. 그렇기에 하나 제대로 만들어 놓고 쓰는 게 실수를 줄일 수 있고 또 함수를 안만들고 여러번 쓴 상황에서 코드가 하나 틀렸다 생각해보자. 그럼 그 기능을 하는 문을 다 찾아서 다 바꿔야한다. 하지만 하나 이쁘게 만들어 놓은 함수에 에러가 있으면 그거 하나만 고치면 된다. 이렇게 고치기 쉽다는 말을 코딩에서 유지보수가 쉽다고 말한다.

## 함수 리터럴

함수 리터럴의 구조는 다음과 같다

```
function 함수명(){};
```

이때 함수명은 생략이 가능하다. 자 이 함수 리터럴은 중의적인 의미를 갖는다. 뭐냐 바로 경우에 따라서 함수 선언문이 되기도, 함수 리터럴(값)이 되기도 한다. 그 차이는 뭘까? 바로 변수 할당이 가능하냐 불가능 하냐의 차이이다. 선언문은 표현식이 아니지 않은가? 그런것이다. 그럼 어떨때 저게 선언문으로 JS엔진이 인식할 까. 

​	먼저 함수 리터럴에 함수명이 생략되지 않은 상태여야한다. 이 상태의 함수 리터럴이 그 자신만으로 존재하면 즉 연산자나 뭐 변수 선언 키워드 다 떼고 function 함수먕(){} 이것만 있으면 함수 선언문으로 JS엔진이 인식한다. 그 외의 경우 리터럴로 인식해서 변수에 선언이 가능하다.



## 함수 정의

함수를 정의하는 법은 여러개이다. 

	- 함수 선언문
	- 함수 표현식
	- 생성자함수
	- 화살표함수

이렇게 다양하게 있는 데 조금식 차이가 존재한다. 선언문의 경우 함수명을 생략할 수 없다. 엔진이 암묵적으로 함수명과 동일한 변수를 만들어서 할당하기 때문에 함수명이 없으면 못만들 지 않겠는가? 또 함수 선언문은 선언문이라 표현식이 아닌 문이다. 그래서 콘솔에 찍으면 undefined를 반환한다.

표현식의 경우 함수명을 생략할 수 있다. 또 그런게 일반적이다. 재귀함수 처럼 함수 내부에서 자신을 사용하는 게 아닌경우엔 생략하자. 다시 말해 함수명은 본인 코드 블럭안에서만 사용이 가능하다. 스코프가 거기 까지라는 의미이다.



## 함수 호이스팅

함수도 변수 처럼 호이스팅이 일어나지만 정의 방식에 따라서 달라진다. 함수 선언문으로 정의한 경우 변수와 동일하게 호이스팅이 일어나기 때문에 정의 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의하면 변수 명으로 선언만되고 할당(초기화)은 런타임에서 실행됨으로 호이스팅이 일어나지 않는 것처럼 보인다. 이 함수 선언문의 호이스팅을 함수 호이스팅이라고 한다.



## Function생성자 함수, 화살표함수

Function생성자 함수는 딱히 자주 쓰이진 않는다 . 그러나 화살표 함수는 매우 자주 쓰이는 중요한 정의 방식이다. 화살표 함수와 선언문,표현식과 다른 점은 argument 프로퍼티를 생성하지 않는 것이다. argument프로퍼티는 인수들을 문자열로 받아서 객체로 저장한 프로퍼티인데, 화살표함수는 오롯이 함수 기능만을 하기위해서 만든 것으로 이런 부수적인 것을 만들지 않는다.



## 함수호출

함수를 호출할 땐 몇 가지 재료가 필요하다.

### 매개변수 인수

먼저 기본 호출 구조는 식별자(인수 들)이다. 이때 재료로 들어갈 인수가 필요하다. 물론 반드시 필요한 것은 아니지만 외부에서 값을 가져와서 처리하고 싶다면 반드시 필요하다. 또 이 인수의 갯수는 함수를 실행하는 데 있어서 별로 중요하지 않다. 다시 말하면 매개 변수보다 많은 인수를 넣던 적은 인수를 넣던 함수는 돌아간다. 많이 넣은 경우에는 그 순서가 중요하지만 일단 되긴한다. 하지만 적게 넣은 경우 매개변수에 값이 할당되지 않게 되어 undefined인상태로 계산되어 진다. 그럼 뭐 예상한 값이 안나오지 않겠는가? 

 인수는 삽입 순서대로 매개변수에 들어간다. 만약 function add(x,t){}라는 함수라면 add(1,2)로 호출하는데 이때 x - 1 t-2가 들어가는것이다. 자 그렇다면 이제 문제가 생긴다. 매개변수가 많은 경우에 우리가 그 함수를 다 외고 있어서 매개변수에 어떤 타입의 값이 들어가야 정확한 계산으로 예측한 결과를 내는 지 알면 좋지만 보통 모를 수있다. 그렇기 때문에 매개변수는 적을 수록 좋은 것이고, 또 앞에서 인수가 어떤 값이 들어올지 모르고 적게 들어올지도 모른다고 했다. 그럼 이럴 경우에 대비해서 안전장치를 만들어줘야한다. 결과값이 이상하게 나오는 건 사용자가 실수한게 아니라 실수하게 만든 사람이 잘못한거다.

## 반환문

함수는 인풋 받아 아웃풋을 반환한다 했다. 그럼 어떻게 반환하는가? var로 하든 const로 하던 별국 블록안이라서 밖에선 못쓰는데. 이걸 위해서 return 키워드가 있다. return키워드는 함수의 마지막에 넣어서 return 다음에 오는 표현식의 값을 함수 식별자의 값으로 만들어 준다. 그래서 그 식별자로 뭔가를 또 할수 있다.



## 참조에 의한 전달

만약 외부에서 값을 받아서 쓰는 함수의 경우에 부수효과를 발생 시킬 수 있다. 이럴 경우 사용자가 변경된 객체의 상태를 알아차리기 어렵다. 이런 함수를 비순수함수라고 하며 이 비순수함수에 의해서 상태가 변경된 객체를 파악하기 위해서 observer패턴등의 코딩패턴이 존재한다.



## 다양한 함수 종류

 ### 즉시 실행함수

함수중에 정의와 동시에 호출되는 함수가 있다. 이를 즉시실행함수라고 하며 이 함수는 재사용이 불가능하다.

함수 리터럴을 그룹 연산자로 묶으면 그 리터럴은 값으로 평가되서 변수 선언, 할당이 암묵적으로 이루어지지 않는다. 이 점을 이용해서 만든 다.



### 재귀함수

함수는 함수인데 코드 블럭에서 본인을 다시 불러 쓰는 함수를 재귀함수라고 한다. 이런 함수는 반복 연산을 구현하는 데 좋지만 자칫 무한루프에 빠질 수 있기 때문에 반드시 탈출문이 필요하다.



### 중첩함수

함수 내부에 함수를 또 쓰는걸 중첩된 함수라고 하며 내부의 함수를 중첩함수, 외부의 함수를 외부 함수라고 한다. 일반적으로 내부 함수는 외부함수의 헬퍼 역할을 한다.

### 콜백함수 

만약 해야하는 일이 여러개 일때, 그 중 몇 가지 일은 반복되서 일어나야하는 경우에 그 기능을 함수로 만들고 인수로 받아서 자연스럽게 내부에서 함수를 또 호출하게 하는 함수를 만들 수 있다. 이 경우 인수로 들어온 함수를 콜백함수라고한다.

### 순수함수 비순수함수

앞에서 말했듯이 부수효과가 있는 함수가 비순수함수이다. 이 함수는 인자로 받는 값에 의존적이라서 그 값에 따라서 반환하는 값이 변한다. 또 그 결과로 외부 상태를 변경한다. 순수함수는 이와 다르게 부수효과도 없고 외부 인수에 의존적이지 않다는 점이다.